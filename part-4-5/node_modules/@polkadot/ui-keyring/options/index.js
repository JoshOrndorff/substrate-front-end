"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rxjs = require("rxjs");

var _util = require("@polkadot/util");

var _observable = _interopRequireDefault(require("../observable"));

// Copyright 2017-2019 @polkadot/ui-keyring authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
let hasCalledInitOptions = false;

const sortByName = (a, b) => {
  const valueA = a.option.name;
  const valueB = b.option.name;
  return valueA.localeCompare(valueB);
};

const sortByCreated = (a, b) => {
  const valueA = a.json.meta.whenCreated || 0;
  const valueB = b.json.meta.whenCreated || 0;

  if (valueA < valueB) {
    return 1;
  }

  if (valueA > valueB) {
    return -1;
  }

  return 0;
};

class KeyringOption {
  constructor() {
    this.optionsSubject = new _rxjs.BehaviorSubject(this.emptyOptions());
  }

  createOptionHeader(name) {
    return {
      className: 'header disabled',
      name,
      key: "header-".concat(name.toLowerCase()),
      text: name,
      value: null
    };
  }

  init(keyring) {
    (0, _util.assert)(!hasCalledInitOptions, 'Unable to initialise options more than once');

    _observable.default.subscribe(() => {
      const options = this.emptyOptions();
      this.addAccounts(keyring, options);
      this.addAddresses(keyring, options);
      this.addContracts(keyring, options);
      options.address = this.linkItems({
        Addresses: options.address,
        Recent: options.recent
      });
      options.account = this.linkItems({
        Accounts: options.account,
        Development: options.testing
      });
      options.contract = this.linkItems({
        Contracts: options.contract
      });
      options.all = [].concat(options.account, options.address);
      options.allPlus = [].concat(options.account, options.address, options.contract);
      this.optionsSubject.next(options);
    });

    hasCalledInitOptions = true;
  }

  linkItems(items) {
    return Object.keys(items).reduce((result, header) => {
      const options = items[header];
      return result.concat(options.length ? [this.createOptionHeader(header)] : [], options);
    }, []);
  }

  addAccounts(keyring, options) {
    const available = keyring.accounts.subject.getValue();
    Object.values(available).sort(sortByName).forEach((_ref) => {
      let {
        json: {
          meta: {
            isTesting = false
          }
        },
        option
      } = _ref;

      if (!isTesting) {
        options.account.push(option);
      } else {
        options.testing.push(option);
      }
    });
  }

  addAddresses(keyring, options) {
    const available = keyring.addresses.subject.getValue();
    Object.values(available).filter((_ref2) => {
      let {
        json
      } = _ref2;
      return !!json.meta.isRecent;
    }).sort(sortByCreated).forEach((_ref3) => {
      let {
        option
      } = _ref3;
      options.recent.push(option);
    });
    Object.values(available).filter((_ref4) => {
      let {
        json
      } = _ref4;
      return !json.meta.isRecent;
    }).sort(sortByName).forEach((_ref5) => {
      let {
        option
      } = _ref5;
      options.address.push(option);
    });
  }

  addContracts(keyring, options) {
    const available = keyring.contracts.subject.getValue();
    Object.values(available).sort(sortByName).forEach((_ref6) => {
      let {
        option
      } = _ref6;
      options.contract.push(option);
    });
  }

  emptyOptions() {
    return {
      account: [],
      address: [],
      contract: [],
      all: [],
      allPlus: [],
      recent: [],
      testing: []
    };
  }

}

const keyringOptionInstance = new KeyringOption();
var _default = keyringOptionInstance;
exports.default = _default;