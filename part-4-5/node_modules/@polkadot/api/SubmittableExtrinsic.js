"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createSubmittableExtrinsic;
exports.SubmittableResult = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _bn = _interopRequireDefault(require("bn.js"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _types = require("@polkadot/types");

var _util = require("@polkadot/util");

var _filterEvents = _interopRequireDefault(require("./util/filterEvents"));

var _SignerPayload = _interopRequireDefault(require("./SignerPayload"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// The default for 6s allowing for 5min eras. When translating this to faster blocks -
//   - 4s = (10 / 15) * 5 = 3.33m
//   - 2s = (10 / 30) * 5 = 1.66m
const BLOCKTIME = 6;
const ONE_MINUTE = 60 / BLOCKTIME;
const DEFAULT_MORTAL_LENGTH = 5 * ONE_MINUTE;

function isKeyringPair(account) {
  return (0, _util.isFunction)(account.sign);
}

class SubmittableResult {
  constructor(_ref) {
    let {
      events,
      status
    } = _ref;
    this.events = void 0;
    this.status = void 0;
    this.events = events || [];
    this.status = status;
  }

  get isCompleted() {
    return this.isError || this.isFinalized;
  }

  get isError() {
    return this.status.isDropped || this.status.isInvalid || this.status.isUsurped;
  }

  get isFinalized() {
    return this.status.isFinalized;
  }
  /**
   * @description Finds an EventRecord for the specified method & section
   */


  findRecord(section, method) {
    return this.events.find((_ref2) => {
      let {
        event
      } = _ref2;
      return event.section === section && event.method === method;
    });
  }

}

exports.SubmittableResult = SubmittableResult;

function createSubmittableExtrinsic(type, api, decorateMethod, extrinsic, trackingCb) {
  const _extrinsic = new ((0, _types.getTypeRegistry)().getOrThrow('Extrinsic'))(extrinsic, {
    version: api.extrinsicType
  });

  const _noStatusCb = type === 'rxjs';

  function updateSigner(updateId, status) {
    if (updateId !== -1 && api.signer && api.signer.update) {
      api.signer.update(updateId, status);
    }
  }

  function statusObservable(status) {
    if (!status.isFinalized) {
      const result = new SubmittableResult({
        status
      });
      trackingCb && trackingCb(result);
      return (0, _rxjs.of)(result);
    }

    const blockHash = status.asFinalized;
    return (0, _rxjs.combineLatest)([api.rpc.chain.getBlock(blockHash), api.query.system.events.at(blockHash)]).pipe((0, _operators.map)((_ref3) => {
      let [signedBlock, allEvents] = _ref3;
      const result = new SubmittableResult({
        events: (0, _filterEvents.default)(_extrinsic.hash, signedBlock, allEvents),
        status
      });
      trackingCb && trackingCb(result);
      return result;
    }));
  }

  function sendObservable() {
    let updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    return api.rpc.author.submitExtrinsic(_extrinsic).pipe((0, _operators.tap)(hash => {
      updateSigner(updateId, hash);
    }));
  }

  function subscribeObservable() {
    let updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    return api.rpc.author.submitAndWatchExtrinsic(_extrinsic).pipe((0, _operators.switchMap)(status => statusObservable(status)), (0, _operators.tap)(status => {
      updateSigner(updateId, status);
    }));
  }

  function expandOptions(options, extras) {
    return _objectSpread({
      blockHash: api.genesisHash,
      version: api.runtimeVersion
    }, options, {}, extras);
  }

  function expandEraOptions(options, _ref4) {
    let {
      header,
      nonce
    } = _ref4;

    if (!header) {
      if ((0, _util.isNumber)(options.era)) {
        // since we have no header, it is immortal, remove any option overrides
        // so we only supply the genesisHash and no era to the construction
        delete options.era;
        delete options.blockHash;
      }

      return expandOptions(options, {
        nonce
      });
    }

    const {
      blockNumber,
      hash
    } = header;
    return expandOptions(options, {
      blockHash: hash,
      era: new _types.ExtrinsicEra({
        current: blockNumber,
        period: options.era || DEFAULT_MORTAL_LENGTH
      }),
      nonce
    });
  }

  const signOrigin = _extrinsic.sign;
  Object.defineProperties(_extrinsic, {
    send: {
      value: function value(statusCb) {
        const isSubscription = _noStatusCb || !!statusCb;
        return decorateMethod(isSubscription ? subscribeObservable : sendObservable)(statusCb);
      }
    },
    sign: {
      value: function value(account, optionOrNonce) {
        // HACK here we actually override nonce if it was specified (backwards compat for
        // the previous signature - don't let userspace break, but allow then time to upgrade)
        const options = (0, _util.isBn)(optionOrNonce) || (0, _util.isNumber)(optionOrNonce) ? {
          nonce: optionOrNonce
        } : optionOrNonce;
        signOrigin.apply(_extrinsic, [account, expandOptions(options, {})]);
        return this;
      }
    },
    signAndSend: {
      value: function value(account, optionsOrStatus, statusCb) {
        let options = {};

        if ((0, _util.isFunction)(optionsOrStatus)) {
          statusCb = optionsOrStatus;
        } else {
          options = _objectSpread({}, optionsOrStatus);
        }

        const isSubscription = _noStatusCb || !!statusCb;
        const address = isKeyringPair(account) ? account.address : account.toString();
        let updateId;
        return decorateMethod(() => (0, _rxjs.combineLatest)([// if we have a nonce already, don't retrieve the latest, use what is there
        (0, _util.isUndefined)(options.nonce) ? api.query.system.accountNonce(address) : (0, _rxjs.of)(new _types.Index(options.nonce)), // if we have an era provided already or eraLength is <= 0 (immortal)
        // don't get the latest block, just pass null, handle in mergeMap
        (0, _util.isUndefined)(options.era) || (0, _util.isNumber)(options.era) && options.era > 0 ? api.rpc.chain.getHeader() : (0, _rxjs.of)(null)]).pipe((0, _operators.first)(), (0, _operators.mergeMap)(async (_ref5) => {
          let [nonce, header] = _ref5;
          const eraOptions = expandEraOptions(options, {
            header,
            nonce
          }); // FIXME This is becoming real messy with all the options - way past
          // "a method should fit on a single screen" stage. (Probably want to
          // clean this when we remove `api.signer.sign` in the next beta cycle)

          if (isKeyringPair(account)) {
            this.sign(account, eraOptions);
          } else if (api.signer) {
            if (api.signer.signPayload) {
              const signPayload = new _SignerPayload.default(_objectSpread({}, eraOptions, {
                address,
                method: _extrinsic.method,
                blockNumber: header ? header.blockNumber : 0,
                genesisHash: api.genesisHash,
                version: api.extrinsicType
              }));
              const result = await api.signer.signPayload(signPayload.toPayload()); // Here we explicitly call `toPayload()` again instead of working with an object
              // (reference) as passed to the signer. This means that we are sure that the
              // payload data is not modified from our inputs, but the signer

              _extrinsic.addSignature(address, result.signature, signPayload.toPayload());

              updateId = result.id;
            } else if (api.signer.sign) {
              console.warn('The Signer.sign interface is deprecated and will be removed in a future version, Swap to using the Signer.signPayload interface instead.');
              updateId = await api.signer.sign(_extrinsic, address, _objectSpread({}, eraOptions, {
                blockNumber: header ? header.blockNumber : new _bn.default(0),
                genesisHash: api.genesisHash
              }));
            } else {
              throw new Error('Invalid signer interface');
            }
          } else {
            throw new Error('no signer exists');
          }
        }), (0, _operators.switchMap)(() => {
          return isSubscription ? subscribeObservable(updateId) : sendObservable(updateId);
        })))(statusCb);
      }
    }
  });
  return _extrinsic;
}