"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _fs = _interopRequireDefault(require("fs"));

var _util = require("@polkadot/util");

var _createType = require("../codec/createType");

var codecClasses = _interopRequireWildcard(require("../codec"));

var primitiveClasses = _interopRequireWildcard(require("../primitive"));

var typeClasses = _interopRequireWildcard(require("../type"));

var definitions = _interopRequireWildcard(require("../srml/definitions"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const HEADER = '/* eslint-disable @typescript-eslint/no-empty-interface */\n// Auto-generated via `yarn build:srmlTs`, do not edit\n\n';
const FOOTER = '\n';
const OUTPUT_FILE = 'types.ts'; // Maps the types as found to the source location. This is used to generate the
// imports in the output file, dep-duped and sorted

function setImports(_ref, types) {
  let {
    codecTypes,
    localTypes,
    ownTypes,
    primitiveTypes,
    substrateTypes
  } = _ref;
  types.forEach(type => {
    if (ownTypes.includes(type)) {// do nothing
    } else if (codecClasses[type]) {
      codecTypes[type] = true;
    } else if (primitiveClasses[type]) {
      primitiveTypes[type] = true;
    } else if (typeClasses[type]) {
      substrateTypes[type] = true;
    } else {
      // find this module inside the exports from the rest
      const [moduleName] = Object.entries(definitions).find((_ref2) => {
        let [, {
          types
        }] = _ref2;
        return Object.keys(types).includes(type);
      }) || [null];

      if (moduleName) {
        localTypes[moduleName][type] = true;
        console.log("\tImporting ".concat(type, " from ../'").concat(moduleName, "/types'"));
      }
    }
  });
} // eslint-disable-next-line @typescript-eslint/no-unused-vars


function errorUnhandled(def, imports) {
  throw new Error("Generate: ".concat(name, ": Unhandled type ").concat(_createType.TypeDefInfo[def.info]));
}

function tsCompact(_ref3, imports) {
  let {
    name: compactName,
    sub
  } = _ref3;
  const def = sub;
  setImports(imports, ['Compact']);

  switch (def.info) {
    case _createType.TypeDefInfo.Plain:
      setImports(imports, [def.type]);
      return "export interface ".concat(compactName, " extends Compact<").concat(def.type, "> {}");

    default:
      throw new Error("Enum: ".concat(compactName, ": Unhandled type ").concat(_createType.TypeDefInfo[def.info]));
  }
}

function tsEnum(_ref4, imports) {
  let {
    name: enumName,
    sub
  } = _ref4;
  setImports(imports, ['Enum']);
  const keys = sub.map((_ref5, index) => {
    let {
      info,
      name,
      type
    } = _ref5;
    const [enumType, asGetter] = type === 'Null' ? ['', ''] : ["(".concat(type, ")"), "  readonly as".concat(name, ": ").concat(type, ";\n")];

    switch (info) {
      case _createType.TypeDefInfo.Plain:
        return "  /**\n   * @description ".concat(index, ":: ").concat(name).concat(enumType, "\n   */\n  readonly is").concat(name, ": boolean;\n").concat(asGetter);

      default:
        throw new Error("Enum: ".concat(enumName, ": Unhandled type ").concat(_createType.TypeDefInfo[info]));
    }
  });
  return "export interface ".concat(enumName, " extends Enum {\n").concat(keys.join(''), "}");
}

function tsOption(_ref6, imports) {
  let {
    name: optionName,
    sub
  } = _ref6;
  const def = sub;
  setImports(imports, ['Option']);

  switch (def.info) {
    case _createType.TypeDefInfo.Plain:
      setImports(imports, [def.type]);
      return "export interface ".concat(optionName, " extends Option<").concat(def.type, "> {}");

    default:
      throw new Error("Enum: ".concat(optionName, ": Unhandled type ").concat(_createType.TypeDefInfo[def.info]));
  }
}

function tsPlain(_ref7, imports) {
  let {
    name: plainName,
    type
  } = _ref7;
  setImports(imports, [type]);
  return "export interface ".concat(plainName, " extends ").concat(type, " {}");
}

function _tsStructGetterType(structName, _ref8, imports) {
  let {
    info,
    sub,
    type
  } = _ref8;

  let _type;

  switch (info) {
    case _createType.TypeDefInfo.Compact:
      _type = sub.type;
      setImports(imports, ['Compact']);
      return [_type, "Compact<".concat(_type, ">")];

    case _createType.TypeDefInfo.Option:
      _type = sub.type;
      setImports(imports, ['Option']);
      return [_type, "Option<".concat(_type, ">")];

    case _createType.TypeDefInfo.Plain:
      return [type, type];

    case _createType.TypeDefInfo.Vector:
      _type = sub.type;
      setImports(imports, ['Vector']);
      return [_type, "Vector<".concat(_type, ">")];

    default:
      throw new Error("Struct: ".concat(structName, ": Unhandled type ").concat(_createType.TypeDefInfo[info]));
  }
}

function tsStruct(_ref9, imports) {
  let {
    name: structName,
    sub
  } = _ref9;
  const keys = sub.map(typedef => {
    const [embedType, returnType] = _tsStructGetterType(structName, typedef, imports);

    setImports(imports, ['Struct', embedType]);
    return "  readonly ".concat(typedef.name, ": ").concat(returnType, ";\n");
  });
  return "export interface ".concat(structName, " extends Struct {\n").concat(keys.join(''), "}");
}

function tsTuple(_ref10, imports) {
  let {
    name: tupleName,
    sub
  } = _ref10;
  const types = sub.map((_ref11) => {
    let {
      type
    } = _ref11;
    setImports(imports, ['Tuple', type]);
    return type;
  }); // TODO We need some way here of identifying the fields

  return "type _".concat(tupleName, " = [").concat(types.join(', '), "];\nexport interface ").concat(tupleName, " extends Codec, _").concat(tupleName, " {}");
}

function tsVector(_ref12, imports) {
  let {
    ext,
    info,
    name: vectorName,
    sub
  } = _ref12;
  const type = info === _createType.TypeDefInfo.VectorFixed ? ext.type : sub.type;
  setImports(imports, ['Vector', type]);
  return "export interface ".concat(vectorName, " extends Vector<").concat(type, "> {}");
} // creates the import lines


function createImportCode(header, checks) {
  return checks.reduce((result, _ref13) => {
    let {
      file,
      types
    } = _ref13;

    if (types.length) {
      result += "import { ".concat(types.sort().join(', '), " } from '../").concat(file, "';\n");
    }

    return result;
  }, header) + '\n';
}

function generateTsDef(srmlName, _ref14) {
  let {
    types
  } = _ref14;
  // handlers are defined externally to use - this means that when we do a
  // `generators[typedef.info](...)` TS will show any unhandled types. Rather
  // we are being explicit in having no handlers where we do not support (yet)
  const generators = {
    [_createType.TypeDefInfo.Compact]: tsCompact,
    [_createType.TypeDefInfo.DoubleMap]: errorUnhandled,
    [_createType.TypeDefInfo.Enum]: tsEnum,
    [_createType.TypeDefInfo.Linkage]: errorUnhandled,
    [_createType.TypeDefInfo.Null]: errorUnhandled,
    [_createType.TypeDefInfo.Option]: tsOption,
    [_createType.TypeDefInfo.Plain]: tsPlain,
    [_createType.TypeDefInfo.Struct]: tsStruct,
    [_createType.TypeDefInfo.Tuple]: tsTuple,
    [_createType.TypeDefInfo.Vector]: tsVector,
    [_createType.TypeDefInfo.VectorFixed]: tsVector
  };
  const codecTypes = {};
  const localTypes = Object.keys(definitions).reduce((localTypes, moduleName) => {
    localTypes[moduleName] = {};
    return localTypes;
  }, {});
  const ownTypes = Object.keys(types);
  const primitiveTypes = {};
  const substrateTypes = {};
  const interfaces = Object.entries(types).map((_ref15) => {
    let [name, type] = _ref15;
    const def = (0, _createType.getTypeDef)((0, _util.isString)(type) ? type.toString() : JSON.stringify(type), name);
    return [name, generators[def.info](def, {
      codecTypes,
      localTypes,
      ownTypes,
      primitiveTypes,
      substrateTypes
    })];
  });
  const sortedDefs = interfaces.sort((a, b) => a[0].localeCompare(b[0])).map((_ref16) => {
    let [, definition] = _ref16;
    return definition;
  }).join('\n\n');
  const header = createImportCode(HEADER, [{
    file: '../types',
    types: codecTypes['Tuple'] ? ['Codec'] : []
  }, {
    file: '../codec',
    types: Object.keys(codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '../primitive',
    types: Object.keys(primitiveTypes)
  }, {
    file: '../type',
    types: Object.keys(substrateTypes)
  }, ...Object.keys(localTypes).map(moduleName => ({
    file: "".concat(moduleName, "/types"),
    types: Object.keys(localTypes[moduleName])
  }))]);

  _fs.default.writeFileSync("packages/types/src/srml/".concat(srmlName, "/").concat(OUTPUT_FILE), header.concat(sortedDefs).concat(FOOTER), {
    flag: 'w'
  });
}

Object.entries(definitions).forEach((_ref17) => {
  let [srmlName, obj] = _ref17;
  console.log("Extracting definitions for ".concat(srmlName));
  generateTsDef(srmlName, obj);
});