"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeSplit = typeSplit;
exports.getTypeDef = getTypeDef;
exports.createClass = createClass;
exports.getTypeClassMap = getTypeClassMap;
exports.getTypeClass = getTypeClass;
exports.ClassOf = ClassOf;
exports.default = createType;
exports.TypeDefInfo = void 0;

var _memoizee = _interopRequireDefault(require("memoizee"));

var _util = require("@polkadot/util");

var _Null = _interopRequireDefault(require("../primitive/Null"));

var _StorageData = _interopRequireDefault(require("../primitive/StorageData"));

var _Compact = _interopRequireDefault(require("./Compact"));

var _Enum = _interopRequireDefault(require("./Enum"));

var _Linkage = _interopRequireDefault(require("./Linkage"));

var _Option = _interopRequireDefault(require("./Option"));

var _Struct = _interopRequireDefault(require("./Struct"));

var _Tuple = _interopRequireDefault(require("./Tuple"));

var _U8aFixed = _interopRequireDefault(require("./U8aFixed"));

var _Vector = _interopRequireDefault(require("./Vector"));

var _VectorFixed = _interopRequireDefault(require("./VectorFixed"));

var _typeRegistry = _interopRequireDefault(require("./typeRegistry"));

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
let TypeDefInfo;
exports.TypeDefInfo = TypeDefInfo;

(function (TypeDefInfo) {
  TypeDefInfo[TypeDefInfo["Compact"] = 0] = "Compact";
  TypeDefInfo[TypeDefInfo["DoubleMap"] = 1] = "DoubleMap";
  TypeDefInfo[TypeDefInfo["Enum"] = 2] = "Enum";
  TypeDefInfo[TypeDefInfo["Linkage"] = 3] = "Linkage";
  TypeDefInfo[TypeDefInfo["Option"] = 4] = "Option";
  TypeDefInfo[TypeDefInfo["Plain"] = 5] = "Plain";
  TypeDefInfo[TypeDefInfo["Struct"] = 6] = "Struct";
  TypeDefInfo[TypeDefInfo["Tuple"] = 7] = "Tuple";
  TypeDefInfo[TypeDefInfo["Vector"] = 8] = "Vector";
  TypeDefInfo[TypeDefInfo["VectorFixed"] = 9] = "VectorFixed";
  TypeDefInfo[TypeDefInfo["Null"] = 10] = "Null";
})(TypeDefInfo || (exports.TypeDefInfo = TypeDefInfo = {}));

// safely split a string on ', ' while taking care of any nested occurences
function typeSplit(type) {
  let cDepth = 0; // compact/doublemap/linkedmap/option/vector depth

  let fDepth = 0; // vector (fixed) depth

  let sDepth = 0; // struct depth

  let tDepth = 0; // tuple depth

  let start = 0;
  const result = [];

  for (let index = 0; index < type.length; index++) {
    switch (type[index]) {
      case ',':
        // we are not nested, add the type
        if (cDepth === 0 && fDepth === 0 && sDepth === 0 && tDepth === 0) {
          result.push(type.substr(start, index - start).trim());
          start = index + 1;
        }

        break;
      // adjust compact/vec (and friends) depth

      case '<':
        cDepth++;
        break;

      case '>':
        cDepth--;
        break;
      // adjust fixed vec depths

      case '[':
        fDepth++;
        break;

      case ']':
        fDepth--;
        break;
      // adjust struct depth

      case '{':
        sDepth++;
        break;

      case '}':
        sDepth--;
        break;
      // adjusttuple depth

      case '(':
        tDepth++;
        break;

      case ')':
        tDepth--;
        break;
      // normal character

      default:
        break;
    }
  }

  (0, _util.assert)(!cDepth && !fDepth && !sDepth && !tDepth, "Invalid defintion (missing terminators) found in ".concat(type)); // the final leg of the journey

  result.push(type.substr(start, type.length - start).trim());
  return result;
}

function getTypeDef(_type, name) {
  const type = _type.toString().trim();

  const value = {
    info: TypeDefInfo.Plain,
    name,
    type
  };
  let subType = '';

  const startingWith = (type, start, end) => {
    if (type.substr(0, start.length) !== start) {
      return false;
    }

    (0, _util.assert)(type[type.length - 1] === end, "Expected '".concat(start, "' closing with '").concat(end, "'"));
    subType = type.substr(start.length, type.length - start.length - 1);
    return true;
  };

  if (startingWith(type, '(', ')')) {
    value.info = TypeDefInfo.Tuple;
    value.sub = typeSplit(subType).map(inner => getTypeDef(inner));
  } else if (startingWith(type, '[', ']')) {
    // this handles e.g. [u8;32]
    const [vecType, _vecLen] = type.substr(1, type.length - 2).split(';');
    const vecLen = parseInt(_vecLen.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support

    (0, _util.assert)(vecLen <= 256, "".concat(type, ": Only support for [Type; <length>], where length <= 256"));
    value.info = TypeDefInfo.VectorFixed;
    value.ext = {
      length: vecLen,
      type: vecType
    };
  } else if (startingWith(type, '{', '}')) {
    const parsed = JSON.parse(type);
    const keys = Object.keys(parsed);

    if (keys.length === 1 && keys[0] === '_enum') {
      const details = parsed[keys[0]]; // not as pretty, but remain compatible with oo7 for both struct and Array types

      value.sub = Array.isArray(details) ? details.map(name => ({
        info: TypeDefInfo.Plain,
        name,
        type: 'Null'
      })) : Object.keys(details).map(name => ({
        info: TypeDefInfo.Plain,
        name,
        type: details[name] || 'Null'
      }));
      value.info = TypeDefInfo.Enum;
    } else {
      value.info = TypeDefInfo.Struct;
      value.sub = keys.map(name => getTypeDef(parsed[name], name));
    }
  } else if (startingWith(type, 'Compact<', '>')) {
    value.info = TypeDefInfo.Compact;
    value.sub = getTypeDef(subType);
  } else if (startingWith(type, 'Option<', '>')) {
    value.info = TypeDefInfo.Option;
    value.sub = getTypeDef(subType);
  } else if (startingWith(type, 'Vec<', '>')) {
    value.info = TypeDefInfo.Vector;
    value.sub = getTypeDef(subType);
  } else if (startingWith(type, 'Linkage<', '>')) {
    value.info = TypeDefInfo.Linkage;
    value.sub = getTypeDef(subType);
  } else if (startingWith(type, 'DoubleMap<', '>')) {
    value.info = TypeDefInfo.DoubleMap;
    value.sub = getTypeDef(subType);
  }

  return value;
} // Memoized helper of the `createClass` function below


const memoizedCreateClass = (0, _memoizee.default)(type => {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  return getTypeClass(getTypeDef(type));
}, {
  length: 1,
  // Normalize args so that different args that should be cached
  // together are cached together.
  // E.g.: `createClass('abc') === createClass(new Text('abc'));`
  normalizer: JSON.stringify
});

function createClass(type) {
  return memoizedCreateClass(type);
} // create an array of constructors from the input


function getTypeClassMap(defs) {
  return defs.reduce((result, sub) => {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    result[sub.name] = getTypeClass(sub);
    return result;
  }, {});
} // Returns the type Class for construction


function getTypeClass(value, Fallback) {
  const Type = (0, _typeRegistry.default)().get(value.type);

  if (Type) {
    return Type;
  }

  switch (value.info) {
    case TypeDefInfo.Compact:
      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for Compact');
      return _Compact.default.with(getTypeClass(value.sub));

    case TypeDefInfo.Enum:
      (0, _util.assert)(value.sub && Array.isArray(value.sub), 'Expected subtype for Enum');
      return _Enum.default.with(getTypeClassMap(value.sub));

    case TypeDefInfo.Option:
      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for Option');
      return _Option.default.with(getTypeClass(value.sub));

    case TypeDefInfo.Struct:
      (0, _util.assert)(Array.isArray(value.sub), 'Expected nested subtypes for Struct');
      return _Struct.default.with(getTypeClassMap(value.sub));

    case TypeDefInfo.Tuple:
      (0, _util.assert)(Array.isArray(value.sub), 'Expected nested subtypes for Tuple');
      return _Tuple.default.with(value.sub.map(Type => getTypeClass(Type)));

    case TypeDefInfo.Vector:
      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for Vector');
      return _Vector.default.with(getTypeClass(value.sub));

    case TypeDefInfo.VectorFixed:
      (0, _util.assert)(value.ext, 'Expected length & type information for fixed vector');
      const ext = value.ext;
      return ext.type === 'u8' ? _U8aFixed.default.with(ext.length * 8) : _VectorFixed.default.with(createClass(ext.type), ext.length);

    case TypeDefInfo.Linkage:
      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for Linkage');
      return _Linkage.default.withKey(getTypeClass(value.sub));

    case TypeDefInfo.DoubleMap:
      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for DoubleMap');
      return getTypeClass(value.sub);

    case TypeDefInfo.Null:
      return _Null.default;
  }

  if (Fallback) {
    return Fallback;
  }

  throw new Error("Unable to determine type from '".concat(value.type, "'"));
} // alias for createClass


function ClassOf(name) {
  return createClass(name);
}

function initType(Type, value, isPedantic) {
  try {
    const created = new Type(value); // in pedantic mode, actually check that the encoding matches that supplied - this
    // is much slower, but ensures that we have a 100% grasp on the actual provided value

    if (isPedantic && value && value.toHex && value.toU8a) {
      const inHex = value.toHex(true);
      const crHex = created.toHex(true);
      (0, _util.assert)(inHex === crHex || // check that the hex matches, if matching, all-ok
      value instanceof _StorageData.default && // input is from storage
      created instanceof Uint8Array && // we are a variable-lneght structure
      value.toU8a(true).toString() === created.toU8a().toString() // strip the input length
      , "Input doesn't match output, received ".concat(inHex, ", created ").concat(crHex));
    }

    return created;
  } catch (error) {
    if (Type.Fallback) {
      return initType(Type.Fallback, value, isPedantic);
    }

    throw error;
  }
}

function createType(type, value, isPedantic) {
  // l.debug(() => ['createType', { type, value }]);
  try {
    return initType(createClass(type), value, isPedantic);
  } catch (error) {
    throw new Error("createType(".concat(type, "):: ").concat(error.message));
  }
}