"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getDefaultRegistry;
exports.TypeRegistry = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _util = require("@polkadot/util");

var _createType = require("./createType");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class TypeRegistry {
  constructor() {
    this._registry = new Map();
  }

  // eslint-disable-next-line no-dupe-class-members
  register(arg1, arg2) {
    if ((0, _util.isString)(arg1)) {
      const name = arg1;
      const type = arg2;

      this._registry.set(name, type);
    } else if ((0, _util.isFunction)(arg1)) {
      const name = arg1.name;
      const type = arg1;

      this._registry.set(name, type);
    } else {
      this.registerObject(arg1);
    }
  }

  registerObject(obj) {
    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    Object.entries(obj).forEach((_ref) => {
      let [name, type] = _ref;

      if (overwrite || !this.get(name)) {
        if ((0, _util.isString)(type)) {
          this._registry.set(name, (0, _createType.createClass)(type));
        } else if ((0, _util.isFunction)(type)) {
          // This _looks_ a bit funny, but `typeof Clazz === 'function'
          this._registry.set(name, type);
        } else {
          this._registry.set(name, (0, _createType.createClass)(JSON.stringify(type)));
        }
      }
    });
  }

  get(name) {
    return this._registry.get(name);
  }

  getOrThrow(name, msg) {
    const type = this.get(name);

    if ((0, _util.isUndefined)(type)) {
      throw new Error(msg || "type ".concat(name, " not found"));
    }

    return type;
  }

}

exports.TypeRegistry = TypeRegistry;
TypeRegistry.defaultRegistry = new TypeRegistry();
let defaultRegistry;

function getDefaultRegistry() {
  if (!defaultRegistry) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const defaultTypes = require('../index.types');

    defaultRegistry = new TypeRegistry();
    defaultRegistry.register(_objectSpread({}, defaultTypes));
  }

  return defaultRegistry;
}