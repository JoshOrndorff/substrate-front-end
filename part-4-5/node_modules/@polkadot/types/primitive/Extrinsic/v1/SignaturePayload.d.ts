import { AnyNumber, AnyU8a, ExtrinsicPayloadValue, IExtrinsicEra, IKeyringPair, IMethod } from '../../../types';
import Struct from '../../../codec/Struct';
import U8a from '../../../codec/U8a';
import Hash from '../../Hash';
import NonceCompact from '../../../type/NonceCompact';
import ExtrinsicEra from '../ExtrinsicEra';
export interface SignaturePayloadValueV1 {
    blockHash: AnyU8a;
    era: AnyU8a | IExtrinsicEra;
    method: AnyU8a | IMethod;
    nonce: AnyNumber;
}
/**
 * @name SignaturePayloadV1
 * @description
 * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based
 * on the contents included
 *
 *   1-8 bytes: The Transaction Compact<Index/Nonce> as provided in the transaction itself.
 *   2+ bytes: The Function Descriptor as provided in the transaction itself.
 *   1/2 bytes: The Transaction Era as provided in the transaction itself.
 *   32 bytes: The hash of the authoring block implied by the Transaction Era and the current block.
 */
export default class SignaturePayloadV1 extends Struct {
    constructor(value?: ExtrinsicPayloadValue | SignaturePayloadValueV1 | Uint8Array | string);
    /**
     * @description The block [[Hash]] the signature applies to (mortal/immortal)
     */
    readonly blockHash: Hash;
    /**
     * @description The [[U8a]] contained in the payload
     */
    readonly method: U8a;
    /**
     * @description The [[ExtrinsicEra]]
     */
    readonly era: ExtrinsicEra;
    /**
     * @description The [[NonceCompact]]
     */
    readonly nonce: NonceCompact;
    /**
     * @description Sign the payload with the keypair
     */
    sign(signerPair: IKeyringPair): Uint8Array;
}
