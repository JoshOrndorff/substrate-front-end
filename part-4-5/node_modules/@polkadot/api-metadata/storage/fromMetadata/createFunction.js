"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createFunction;

var _types = require("@polkadot/types");

var _Storage = require("@polkadot/types/Metadata/v6/Storage");

var _util = require("@polkadot/util");

var _getHasher = _interopRequireDefault(require("./getHasher"));

// Copyright 2017-2019 @polkadot/api-metadata authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.

/**
 * From the schema of a function in the module's storage, generate the function
 * that will return the correct storage key.
 *
 * @param schema - The function's definition schema to create the function from.
 * The schema is taken from state_getMetadata.
 * @param options - Additional options when creating the function. These options
 * are not known at runtime (from state_getMetadata), they need to be supplied
 * by us manually at compile time.
 */
function createFunction(_ref) {
  let {
    meta,
    method,
    prefix,
    section
  } = _ref;
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const stringKey = options.key ? options.key : "".concat(prefix, " ").concat(method);
  const rawKey = (0, _util.stringToU8a)(stringKey); // Get the hashing function

  let hasher;
  let key2Hasher;

  if (meta.type.isDoubleMap) {
    hasher = (0, _getHasher.default)(meta.type.asDoubleMap.hasher);
    key2Hasher = (0, _getHasher.default)(meta.type.asDoubleMap.key2Hasher);
  } else if (meta.type.isMap) {
    hasher = (0, _getHasher.default)(meta.type.asMap.hasher);
  } else {
    hasher = (0, _getHasher.default)();
  } // Can only have zero or one argument:
  // - storage.balances.freeBalance(address)
  // - storage.timestamp.blockPeriod()


  const _storageFn = arg => {
    let key = rawKey;

    if (meta.type.isDoubleMap) {
      (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) && !(0, _util.isUndefined)(arg[0]) && !(0, _util.isNull)(arg[0]) && !(0, _util.isUndefined)(arg[1]) && !(0, _util.isNull)(arg[1]), "".concat(meta.name, " expects two arguments"));
      const type1 = meta.type.asDoubleMap.key1.toString();
      const type2 = meta.type.asDoubleMap.key2.toString();
      const param1Encoded = (0, _util.u8aConcat)(key, (0, _types.createType)(type1, arg[0]).toU8a(true));
      const param1Hashed = hasher(param1Encoded);
      const param2Hashed = key2Hasher((0, _types.createType)(type2, arg[1]).toU8a(true));
      return _types.Compact.addLengthPrefix((0, _util.u8aConcat)(param1Hashed, param2Hashed));
    }

    if (meta.type.isMap) {
      (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), "".concat(meta.name, " expects one argument"));
      const type = meta.type.asMap.key.toString();
      const param = (0, _types.createType)(type, arg).toU8a();
      key = (0, _util.u8aConcat)(key, param);
    } // StorageKey is a Bytes, so is length-prefixed


    return _types.Compact.addLengthPrefix(options.skipHashing ? key : hasher(key));
  };

  const storageFn = _storageFn;
  storageFn.meta = meta;
  storageFn.method = (0, _util.stringLowerFirst)(method);
  storageFn.prefix = prefix;
  storageFn.section = section;

  storageFn.toJSON = () => meta.toJSON();

  if (meta.type.isMap && meta.type.asMap.isLinked) {
    const keyHash = new _types.U8a(hasher("head of ".concat(stringKey)));

    const keyFn = () => keyHash; // metadata with a flabbcak value using the type of the key, the normal
    // meta fallback only applies to actual entry values, create one for head


    keyFn.meta = new _Storage.StorageEntryMetadata({
      name: meta.name,
      modifier: new _Storage.StorageEntryModifier('Required'),
      type: new _Storage.StorageEntryType(new _Storage.PlainType(meta.type.asMap.key), 0),
      fallback: new _types.Bytes((0, _types.createType)(meta.type.asMap.key).toHex()),
      documentation: meta.documentation
    }); // here we pass the section/methos through as well - these are not on
    // the function itself, so specify these explicitly to the constructor

    storageFn.headKey = new _types.StorageKey(keyFn, {
      method: storageFn.method,
      section: "head of ".concat(storageFn.section)
    }); // adjust the fallback value - the metadata only specifies the value
    // part, add a Linkage<Type> to the fallback aswell. The additional
    // bytes here is a represnettaion of teh Options for next/prev

    meta.set('fallback', new _types.Bytes(meta.fallback.toHex().concat('0000')));
  }

  return storageFn;
}