"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.web3Enable = web3Enable;
exports.web3Accounts = web3Accounts;
exports.web3AccountsSubscribe = web3AccountsSubscribe;
exports.web3FromSource = web3FromSource;
exports.web3FromAddress = web3FromAddress;
exports.web3EnablePromise = exports.isWeb3Injected = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _compat = _interopRequireDefault(require("./compat"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// just a helper (otherwise we cast all-over, so shorter and more readable)
const win = window; // don't clobber the existing object, but ensure non-undefined

win.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available

function web3IsInjected() {
  return Object.keys(win.injectedWeb3).length !== 0;
} // helper to throw a consistent error when not enabled


function throwError(method) {
  throw new Error("".concat(method, ": web3Enable(originName) needs to be called before ").concat(method));
} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>


function mapAccounts(source, list) {
  return list.map((_ref) => {
    let {
      address,
      name
    } = _ref;
    return {
      address,
      meta: {
        name,
        source
      }
    };
  });
} // have we found a properly constructed window.injectedWeb3


let isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)

exports.isWeb3Injected = isWeb3Injected;
let web3EnablePromise = null;
exports.web3EnablePromise = web3EnablePromise;

// enables all the providers found on the injected window interface
function web3Enable(originName) {
  exports.web3EnablePromise = web3EnablePromise = (0, _compat.default)().then(() => Promise.all(Object.entries(win.injectedWeb3).map((_ref2) => {
    let [name, {
      enable,
      version
    }] = _ref2;
    return Promise.all([Promise.resolve({
      name,
      version
    }), enable(originName).catch(error => {
      console.error("Error initializing ".concat(name, ": ").concat(error.message));
    })]);
  })).then(values => values.filter((_ref3) => {
    let [, ext] = _ref3;
    return !!ext;
  }).map((_ref4) => {
    let [info, ext] = _ref4;

    // if we don't have an accounts subscriber, add a single-shot version
    if (ext && !ext.accounts.subscribe) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ext.accounts.subscribe = cb => {
        ext.accounts.get().then(cb).catch(console.error);
        return () => {// no ubsubscribe needed, this is a single-shot
        };
      };
    }

    const injected = _objectSpread({}, info, {}, ext);

    return injected;
  })).catch(() => []).then(values => {
    const names = values.map((_ref5) => {
      let {
        name,
        version
      } = _ref5;
      return "".concat(name, "/").concat(version);
    });
    exports.isWeb3Injected = isWeb3Injected = web3IsInjected();
    console.log("web3Enable: Enabled ".concat(values.length, " extension").concat(values.length !== 1 ? 's' : '', ": ").concat(names.join(', ')));
    return values;
  }));
  return web3EnablePromise;
} // retrieve all the accounts accross all providers


async function web3Accounts() {
  if (!web3EnablePromise) {
    return throwError('web3Accounts');
  }

  const accounts = [];
  const injected = await web3EnablePromise;
  const retrieved = await Promise.all(injected.map(async (_ref6) => {
    let {
      accounts,
      name: source
    } = _ref6;

    try {
      const list = await accounts.get();
      return mapAccounts(source, list);
    } catch (error) {
      // cannot handle this one
      return [];
    }
  }));
  retrieved.forEach(result => {
    accounts.push(...result);
  });
  const addresses = accounts.map((_ref7) => {
    let {
      address
    } = _ref7;
    return address;
  });
  console.log("web3Accounts: Found ".concat(accounts.length, " address").concat(accounts.length !== 1 ? 'es' : '', ": ").concat(addresses.join(', ')));
  return accounts;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


async function web3AccountsSubscribe(cb) {
  if (!web3EnablePromise) {
    return throwError('web3AccountsSubscribe');
  }

  const accounts = {};

  const triggerUpdate = () => {
    cb(Object.entries(accounts).reduce((result, _ref8) => {
      let [source, list] = _ref8;
      result.push(...mapAccounts(source, list));
      return result;
    }, []));
  };

  const unsubs = (await web3EnablePromise).map((_ref9) => {
    let {
      accounts: {
        subscribe
      },
      name: source
    } = _ref9;
    return subscribe(result => {
      accounts[source] = result;
      triggerUpdate();
    });
  });
  return () => {
    unsubs.forEach(unsub => {
      unsub();
    });
  };
} // find a specific provider based on the name


async function web3FromSource(source) {
  if (!web3EnablePromise) {
    return throwError('web3FromSource');
  }

  const sources = await web3EnablePromise;
  const found = source && sources.find((_ref10) => {
    let {
      name
    } = _ref10;
    return name === source;
  });

  if (!found) {
    throw new Error("web3FromSource: Unable to find an injected ".concat(source));
  }

  return found;
} // find a specific provider based on an address


async function web3FromAddress(address) {
  if (!web3EnablePromise) {
    return throwError('web3FromAddress');
  }

  const accounts = await web3Accounts();
  const found = address && accounts.find(account => account.address === address);

  if (!found) {
    throw new Error("web3FromAddress: Unable to find injected ".concat(address));
  }

  return web3FromSource(found.meta.source);
}