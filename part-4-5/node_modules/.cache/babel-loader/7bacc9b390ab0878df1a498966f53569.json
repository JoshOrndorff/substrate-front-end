{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _types = require(\"@polkadot/types\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * @name HeaderExtended\n * @description\n * A [[Block]] header with an additional `author` field that indicates the block author\n */\n\n\nclass HeaderExtended extends _types.Header {\n  constructor() {\n    let header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let sessionValidators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super(header);\n    this._author = void 0;\n\n    if (!header || !header.digest || !sessionValidators.length) {\n      return;\n    }\n\n    let slot;\n\n    const _header$digest$logsWi = header.digest.logsWith('PreRuntime'),\n          _header$digest$logsWi2 = _slicedToArray(_header$digest$logsWi, 1),\n          pitem = _header$digest$logsWi2[0]; // extract from the substrate 2.0 PreRuntime digest\n\n\n    if (pitem) {\n      const preRuntime = pitem.asPreRuntime;\n\n      if (preRuntime.engine.isAura) {\n        slot = preRuntime.slot;\n      }\n    } else {\n      const _header$digest$logsWi3 = header.digest.logsWith('Consensus'),\n            _header$digest$logsWi4 = _slicedToArray(_header$digest$logsWi3, 1),\n            citem = _header$digest$logsWi4[0]; // extract author from the consensus (substrate 1.0, digest)\n\n\n      if (citem) {\n        const consensus = citem.asConsensus;\n\n        if (consensus.engine.isAura) {\n          slot = consensus.slot;\n        }\n      } else {\n        const _header$digest$logsWi5 = header.digest.logsWith('SealV0'),\n              _header$digest$logsWi6 = _slicedToArray(_header$digest$logsWi5, 1),\n              sitem = _header$digest$logsWi6[0]; // extract author from the seal (pre substrate 1.0, backwards compat)\n\n\n        if (sitem) {\n          slot = sitem.asSealV0.slot;\n        }\n      }\n    } // found a slot? Great, extract the validator\n\n\n    if (slot) {\n      this._author = sessionValidators[slot.modn(sessionValidators.length)];\n    }\n  }\n  /**\n   * @description Convenience method, returns the author for the block\n   */\n\n\n  get author() {\n    return this._author;\n  }\n  /**\n   * @description Creates the JSON representation\n   */\n\n\n  toJSON() {\n    return _objectSpread({}, super.toJSON(), {\n      author: this.author ? this.author.toJSON() : undefined\n    });\n  }\n\n}\n\nexports.default = HeaderExtended;","map":null,"metadata":{},"sourceType":"script"}