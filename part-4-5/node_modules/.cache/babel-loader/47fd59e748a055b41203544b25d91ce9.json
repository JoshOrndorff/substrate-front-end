{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.DEFAULT_UINT_BITS = void 0;\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _util = require(\"@polkadot/util\"); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst DEFAULT_UINT_BITS = 64;\n/**\n * @name AbstractInt\n * @ignore\n * @noInheritDoc\n */\n// TODO:\n//   - Apart from encoding/decoding we don't actually keep check on the sizes, is this good enough?\n\nexports.DEFAULT_UINT_BITS = DEFAULT_UINT_BITS;\n\nclass AbstractInt extends _bn.default {\n  constructor(isNegative) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let bitLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_UINT_BITS;\n    let isHexJson = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    super(AbstractInt.decodeAbstracInt(value, bitLength, isNegative));\n    this._bitLength = void 0;\n    this._isHexJson = void 0;\n    this._isNegative = void 0;\n    this._bitLength = bitLength;\n    this._isHexJson = isHexJson;\n    this._isNegative = isNegative;\n  }\n\n  static decodeAbstracInt(value, bitLength, isNegative) {\n    // This function returns a string, which will be passed in the BN\n    // constructor. It would be ideal to actually return a BN, but there's a\n    // bug: https://github.com/indutny/bn.js/issues/206.\n    if ((0, _util.isHex)(value)) {\n      return (0, _util.hexToBn)(value, {\n        isLe: false,\n        isNegative\n      }).toString();\n    } else if ((0, _util.isU8a)(value)) {\n      if (!value.length) {\n        return '0';\n      }\n\n      try {\n        // NOTE When passing u8a in (typically from decoded data), it is always Little Endian\n        return (0, _util.u8aToBn)(value.subarray(0, bitLength / 8), {\n          isLe: true,\n          isNegative\n        }).toString();\n      } catch (error) {\n        throw new Error(\"AbstractInt: failed on \".concat(JSON.stringify(value), \":: \").concat(error.message));\n      }\n    } else if ((0, _util.isString)(value)) {\n      return new _bn.default(value, 10).toString();\n    }\n\n    return (0, _util.bnToBn)(value).toString();\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this._bitLength / 8;\n  }\n  /**\n   * @description Checks if the value is a zero value (align elsewhere)\n   */\n\n\n  get isEmpty() {\n    return this.isZero();\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n\n\n  bitLength() {\n    return this._bitLength;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  eq(other) {\n    // Here we are actually overriding the built-in .eq to take care of both\n    // number and BN inputs (no `.eqn` needed) - numbers will be converted\n    return super.eq((0, _util.isHex)(other) ? (0, _util.hexToBn)(other.toString(), {\n      isLe: false,\n      isNegative: this._isNegative\n    }) : (0, _util.bnToBn)(other));\n  }\n  /**\n   * @description Returns the BN representation of the number. (Compatibility)\n   */\n\n\n  toBn() {\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    // FIXME this return type should by string | number, but BN's return type\n    // is string.\n    // Maximum allowed integer for JS is 2^53 - 1, set limit at 52\n    return this._isHexJson || super.bitLength() > 52 ? this.toHex() : this.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n  /**\n   * @description Returns the string representation of the value\n   * @param base The base to use for the conversion\n   */\n\n\n  toString(base) {\n    // only included here since we do not inherit docs\n    return super.toString(base);\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n}\n\nexports.default = AbstractInt;","map":null,"metadata":{},"sourceType":"script"}