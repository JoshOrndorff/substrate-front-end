{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _types = require(\"@polkadot/types\");\n\nvar _Storage = require(\"@polkadot/types/Metadata/v6/Storage\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\")); // Copyright 2017-2019 @polkadot/api-metadata authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * From the schema of a function in the module's storage, generate the function\n * that will return the correct storage key.\n *\n * @param schema - The function's definition schema to create the function from.\n * The schema is taken from state_getMetadata.\n * @param options - Additional options when creating the function. These options\n * are not known at runtime (from state_getMetadata), they need to be supplied\n * by us manually at compile time.\n */\n\n\nfunction createFunction(_ref) {\n  let meta = _ref.meta,\n      method = _ref.method,\n      prefix = _ref.prefix,\n      section = _ref.section;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const stringKey = options.key ? options.key : \"\".concat(prefix, \" \").concat(method);\n  const rawKey = (0, _util.stringToU8a)(stringKey); // Get the hashing function\n\n  let hasher;\n  let key2Hasher;\n\n  if (meta.type.isDoubleMap) {\n    hasher = (0, _getHasher.default)(meta.type.asDoubleMap.hasher);\n    key2Hasher = (0, _getHasher.default)(meta.type.asDoubleMap.key2Hasher);\n  } else if (meta.type.isMap) {\n    hasher = (0, _getHasher.default)(meta.type.asMap.hasher);\n  } else {\n    hasher = (0, _getHasher.default)();\n  } // Can only have zero or one argument:\n  // - storage.balances.freeBalance(address)\n  // - storage.timestamp.blockPeriod()\n\n\n  const _storageFn = arg => {\n    let key = rawKey;\n\n    if (meta.type.isDoubleMap) {\n      (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) && !(0, _util.isUndefined)(arg[0]) && !(0, _util.isNull)(arg[0]) && !(0, _util.isUndefined)(arg[1]) && !(0, _util.isNull)(arg[1]), \"\".concat(meta.name, \" expects two arguments\"));\n      const type1 = meta.type.asDoubleMap.key1.toString();\n      const type2 = meta.type.asDoubleMap.key2.toString();\n      const param1Encoded = (0, _util.u8aConcat)(key, (0, _types.createType)(type1, arg[0]).toU8a(true));\n      const param1Hashed = hasher(param1Encoded);\n      const param2Hashed = key2Hasher((0, _types.createType)(type2, arg[1]).toU8a(true));\n      return _types.Compact.addLengthPrefix((0, _util.u8aConcat)(param1Hashed, param2Hashed));\n    }\n\n    if (meta.type.isMap) {\n      (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), \"\".concat(meta.name, \" expects one argument\"));\n      const type = meta.type.asMap.key.toString();\n      const param = (0, _types.createType)(type, arg).toU8a();\n      key = (0, _util.u8aConcat)(key, param);\n    } // StorageKey is a Bytes, so is length-prefixed\n\n\n    return _types.Compact.addLengthPrefix(options.skipHashing ? key : hasher(key));\n  };\n\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section;\n\n  storageFn.toJSON = () => meta.toJSON();\n\n  if (meta.type.isMap && meta.type.asMap.isLinked) {\n    const keyHash = new _types.U8a(hasher(\"head of \".concat(stringKey)));\n\n    const keyFn = () => keyHash; // metadata with a flabbcak value using the type of the key, the normal\n    // meta fallback only applies to actual entry values, create one for head\n\n\n    keyFn.meta = new _Storage.StorageEntryMetadata({\n      name: meta.name,\n      modifier: new _Storage.StorageEntryModifier('Required'),\n      type: new _Storage.StorageEntryType(new _Storage.PlainType(meta.type.asMap.key), 0),\n      fallback: new _types.Bytes((0, _types.createType)(meta.type.asMap.key).toHex()),\n      documentation: meta.documentation\n    }); // here we pass the section/methos through as well - these are not on\n    // the function itself, so specify these explicitly to the constructor\n\n    storageFn.headKey = new _types.StorageKey(keyFn, {\n      method: storageFn.method,\n      section: \"head of \".concat(storageFn.section)\n    }); // adjust the fallback value - the metadata only specifies the value\n    // part, add a Linkage<Type> to the fallback aswell. The additional\n    // bytes here is a represnettaion of teh Options for next/prev\n\n    meta.set('fallback', new _types.Bytes(meta.fallback.toHex().concat('0000')));\n  }\n\n  return storageFn;\n}","map":null,"metadata":{},"sourceType":"script"}