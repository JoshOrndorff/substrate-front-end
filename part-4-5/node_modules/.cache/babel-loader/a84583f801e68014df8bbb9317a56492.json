{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.EventId = exports.EventData = exports.EventIndex = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Struct = _interopRequireDefault(require(\"../codec/Struct\"));\n\nvar _Tuple = _interopRequireDefault(require(\"../codec/Tuple\"));\n\nvar _U8aFixed = _interopRequireDefault(require(\"../codec/U8aFixed\"));\n\nvar _createType = require(\"../codec/createType\");\n\nvar _Null = _interopRequireDefault(require(\"./Null\"));\n\nvar _U = _interopRequireDefault(require(\"./U32\"));\n\nvar _Unconstructable = _interopRequireDefault(require(\"./Unconstructable\")); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst EventTypes = {};\n/**\n * @name EventIndex\n * @description\n * The Substrate EventIndex representation as a [[U32]].\n */\n\nclass EventIndex extends _U.default {}\n/**\n * @name EventData\n * @description\n * Wrapper for the actual data that forms part of an [[Event]]\n */\n\n\nexports.EventIndex = EventIndex;\n\nclass EventData extends _Tuple.default {\n  constructor(Types, value, typeDef, meta, section, method) {\n    super(Types, value);\n    this._meta = void 0;\n    this._method = void 0;\n    this._section = void 0;\n    this._typeDef = void 0;\n    this._meta = meta;\n    this._method = method;\n    this._section = section;\n    this._typeDef = typeDef;\n  }\n  /**\n   * @description The wrapped [[EventMetadata]]\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description The method as a string\n   */\n\n\n  get method() {\n    return this._method;\n  }\n  /**\n   * @description The section as a string\n   */\n\n\n  get section() {\n    return this._section;\n  }\n  /**\n   * @description The [[TypeDef]] for this event\n   */\n\n\n  get typeDef() {\n    return this._typeDef;\n  }\n\n}\n/**\n * @name EventId\n * @description\n * This follows the same approach as in [[Method]], we have the `[sectionIndex, methodIndex]` pairing\n * that indicates the actual event fired\n */\n\n\nexports.EventData = EventData;\n\nclass EventId extends _U8aFixed.default {\n  constructor(value) {\n    super(value, 16);\n  }\n\n}\n/**\n * @name Event\n * @description\n * A representation of a system event. These are generated via the [[Metadata]] interfaces and\n * specific to a specific Substrate runtime\n */\n\n\nexports.EventId = EventId;\n\nclass Event extends _Struct.default {\n  // Currently we _only_ decode from Uint8Array, since we expect it to\n  // be used via EventRecord\n  constructor(_value) {\n    const _Event$decodeEvent = Event.decodeEvent(_value),\n          DataType = _Event$decodeEvent.DataType,\n          value = _Event$decodeEvent.value;\n\n    super({\n      index: EventId,\n      data: DataType\n    }, value);\n  }\n\n  static decodeEvent() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n\n    if (!value.length) {\n      return {\n        DataType: _Null.default\n      };\n    }\n\n    const index = value.subarray(0, 2);\n    const DataType = EventTypes[index.toString()];\n    (0, _util.assert)(!(0, _util.isUndefined)(DataType), \"Unable to decode \".concat((0, _util.u8aToHex)(index)));\n    return {\n      DataType,\n      value: {\n        index,\n        data: value.subarray(2)\n      }\n    };\n  } // This is called/injected by the API on init, allowing a snapshot of\n  // the available system events to be used in lookups\n\n\n  static injectMetadata(metadata) {\n    metadata.asV7.modules.filter(section => section.events.isSome).forEach((section, sectionIndex) => {\n      const sectionName = (0, _util.stringCamelCase)(section.name.toString());\n      section.events.unwrap().forEach((meta, methodIndex) => {\n        const methodName = meta.name.toString();\n        const eventIndex = new Uint8Array([sectionIndex, methodIndex]);\n        const typeDef = meta.args.map(arg => (0, _createType.getTypeDef)(arg));\n        const Types = typeDef.map(typeDef => (0, _createType.getTypeClass)(typeDef, _Unconstructable.default.with(typeDef)));\n        EventTypes[eventIndex.toString()] = class extends EventData {\n          constructor(value) {\n            super(Types, value, typeDef, meta, sectionName, methodName);\n          }\n\n        };\n      });\n    });\n  }\n  /**\n   * @description The wrapped [[EventData]]\n   */\n\n\n  get data() {\n    return this.get('data');\n  }\n  /**\n   * @description The [[EventId]], identifying the raw event\n   */\n\n\n  get index() {\n    return this.get('index');\n  }\n  /**\n   * @description The [[EventMetadata]] with the documentation\n   */\n\n\n  get meta() {\n    return this.data.meta;\n  }\n  /**\n   * @description The method string identifying the event\n   */\n\n\n  get method() {\n    return this.data.method;\n  }\n  /**\n   * @description The section string identifying the event\n   */\n\n\n  get section() {\n    return this.data.section;\n  }\n  /**\n   * @description The [[TypeDef]] for the event\n   */\n\n\n  get typeDef() {\n    return this.data.typeDef;\n  }\n\n}\n\nexports.default = Event;","map":null,"metadata":{},"sourceType":"script"}