{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Null = _interopRequireDefault(require(\"../primitive/Null\"));\n\nvar _Base = _interopRequireDefault(require(\"./Base\")); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\n// TODO:\n//   - As per Enum, actually use TS enum\n//   - It should rather probably extend Enum instead of copying code\n\n\nclass Enum extends _Base.default {\n  constructor(def, value, index) {\n    const defInfo = Enum.extractDef(def);\n    const decoded = Enum.decodeEnum(defInfo.def, value, index);\n    super(decoded.value);\n    this._def = void 0;\n    this._index = void 0;\n    this._indexes = void 0;\n    this._isBasic = void 0;\n    this._def = defInfo.def;\n    this._isBasic = defInfo.isBasic;\n    this._indexes = Object.keys(defInfo.def).map((_, index) => index);\n    this._index = this._indexes.indexOf(decoded.index) || 0;\n  }\n\n  static extractDef(def) {\n    if (!Array.isArray(def)) {\n      return {\n        def,\n        isBasic: false\n      };\n    }\n\n    return {\n      def: def.reduce((def, key) => {\n        def[key] = _Null.default;\n        return def;\n      }, {}),\n      isBasic: true\n    };\n  }\n\n  static decodeEnum(def, value, index) {\n    // If `index` is set, we parse it.\n    if (index instanceof Enum) {\n      return Enum.createValue(def, index._index, index.raw);\n    } else if ((0, _util.isNumber)(index)) {\n      return Enum.createValue(def, index, value);\n    } // Or else, we just look at `value`\n\n\n    return Enum.decodeViaValue(def, value);\n  }\n\n  static decodeViaValue(def, value) {\n    if (value instanceof Enum) {\n      return Enum.createValue(def, value._index, value.raw);\n    } else if ((0, _util.isU8a)(value)) {\n      return Enum.createValue(def, value[0], value.subarray(1));\n    } else if ((0, _util.isNumber)(value)) {\n      return Enum.createValue(def, value);\n    } else if ((0, _util.isString)(value)) {\n      const _str = value.toString();\n\n      return (0, _util.isHex)(_str) ? Enum.decodeViaValue(def, (0, _util.hexToU8a)(_str)) : Enum.createViaJSON(def, _str);\n    } else if ((0, _util.isObject)(value)) {\n      const key = Object.keys(value)[0];\n      return Enum.createViaJSON(def, key, value[key]);\n    } // Worst-case scenario, return the first with default\n\n\n    return Enum.createValue(def, 0);\n  }\n\n  static createViaJSON(def, key, value) {\n    // JSON comes in the form of { \"<type (lowercased)>\": \"<value for type>\" }, here we\n    // additionally force to lower to ensure forward compat\n    const keys = Object.keys(def).map(k => k.toLowerCase());\n    const keyLower = key.toLowerCase();\n    const index = keys.indexOf(keyLower);\n    (0, _util.assert)(index !== -1, \"Cannot map Enum JSON, unable to find '\".concat(key, \"' in \").concat(keys.join(', ')));\n    return Enum.createValue(def, index, value);\n  }\n\n  static createValue(def) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let value = arguments.length > 2 ? arguments[2] : undefined;\n    const Clazz = Object.values(def)[index];\n    (0, _util.assert)(!(0, _util.isUndefined)(Clazz), \"Unable to create Enum via index \".concat(index, \", in \").concat(Object.keys(def).join(', ')));\n    return {\n      index,\n      value: new Clazz(value)\n    };\n  }\n\n  static with(Types) {\n    return class extends Enum {\n      constructor(value, index) {\n        super(Types, value, index);\n        Object.keys(this._def).forEach(_key => {\n          const askey = \"as\".concat(_key);\n          const iskey = \"is\".concat(_key); // do not clobber existing properties on the object\n\n          if ((0, _util.isUndefined)(this[iskey])) {\n            Object.defineProperty(this, iskey, {\n              enumerable: true,\n              get: () => this.type === _key\n            });\n          }\n\n          if ((0, _util.isUndefined)(this[askey])) {\n            Object.defineProperty(this, askey, {\n              enumerable: true,\n              get: () => {\n                (0, _util.assert)(this[iskey], \"Cannot convert \".concat(this.type, \" via \").concat(askey));\n                return this.value;\n              }\n            });\n          }\n        });\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return 1 + this.raw.encodedLength;\n  }\n  /**\n   * @description The index of the metadata value\n   */\n\n\n  get index() {\n    return this._index;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   */\n\n\n  get isNone() {\n    return this.isNull;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)\n   */\n\n\n  get isNull() {\n    return this.raw instanceof _Null.default;\n  }\n  /**\n   * @description The name of the type this enum value represents\n   */\n\n\n  get type() {\n    return Object.keys(this._def)[this._index];\n  }\n  /**\n   * @description The value of the enum\n   */\n\n\n  get value() {\n    return this.raw;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    // cater for the case where we only pass the enum index\n    if ((0, _util.isNumber)(other)) {\n      return this.toNumber() === other;\n    } else if (this._isBasic && (0, _util.isString)(other)) {\n      return this.type === other;\n    } // compare the actual wrapper value\n\n\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return (0, _util.u8aToHex)(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this._isBasic ? this._index : {\n      [this.type]: this.raw.toJSON()\n    };\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n\n\n  toNumber() {\n    return this._index;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    const _enum = this._isBasic ? Object.keys(this._def) : Object.entries(this._def).reduce((result, _ref) => {\n      let _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          Type = _ref2[1];\n\n      result[key] = new Type().toRawType();\n      return result;\n    }, {});\n\n    return JSON.stringify({\n      _enum\n    });\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.isNull ? this.type : JSON.stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const index = this._indexes[this._index];\n    return (0, _util.u8aConcat)(new Uint8Array([index]), this.raw.toU8a(isBare));\n  }\n\n}\n\nexports.default = Enum;","map":null,"metadata":{},"sourceType":"script"}