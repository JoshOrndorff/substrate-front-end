{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _memoizee = _interopRequireDefault(require(\"memoizee\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _jsonrpc = _interopRequireDefault(require(\"@polkadot/jsonrpc\"));\n\nvar _types = require(\"@polkadot/types\");\n\nvar _util = require(\"@polkadot/util\"); // Copyright 2017-2019 @polkadot/rpc-core authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst l = (0, _util.logger)('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      isLinked: false\n    },\n    isMap: false\n  }\n};\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import WsProvider from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\n\nclass Rpc {\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  constructor(provider) {\n    this._storageCache = new Map();\n    this.provider = void 0;\n    this.author = void 0;\n    this.chain = void 0;\n    this.state = void 0;\n    this.system = void 0;\n    (0, _util.assert)(provider && (0, _util.isFunction)(provider.send), 'Expected Provider to API create');\n    this.provider = provider;\n    this.author = this.createInterface(_jsonrpc.default.author);\n    this.chain = this.createInterface(_jsonrpc.default.chain);\n    this.state = this.createInterface(_jsonrpc.default.state);\n    this.system = this.createInterface(_jsonrpc.default.system);\n  }\n  /**\n   * @name signature\n   * @summary Returns a string representation of the method with inputs and outputs.\n   * @description\n   * Formats the name, inputs and outputs into a human-readable string. This contains the input parameter names input types and output type.\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/rpc-core';\n   *\n   * Api.signature({ name: 'test_method', params: [ { name: 'dest', type: 'Address' } ], type: 'Address' }); // => test_method (dest: Address): Address\n   * ```\n   */\n\n\n  static signature(_ref) {\n    let method = _ref.method,\n        params = _ref.params,\n        type = _ref.type;\n    const inputs = params.map(_ref2 => {\n      let name = _ref2.name,\n          type = _ref2.type;\n      return \"\".concat(name, \": \").concat(type);\n    }).join(', ');\n    return \"\".concat(method, \" (\").concat(inputs, \"): \").concat(type);\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n\n\n  disconnect() {\n    this.provider.disconnect();\n  }\n\n  createErrorMessage(method, error) {\n    return \"\".concat(Rpc.signature(method), \":: \").concat(error.message);\n  }\n\n  createInterface(_ref3) {\n    let methods = _ref3.methods;\n    return Object.keys(methods).reduce((exposed, methodName) => {\n      const def = methods[methodName];\n      exposed[methodName] = def.isSubscription ? this.createMethodSubscribe(def) : this.createMethodSend(def);\n      return exposed;\n    }, {});\n  }\n\n  createMethodSend(method) {\n    var _this = this;\n\n    const rpcName = \"\".concat(method.section, \"_\").concat(method.method);\n\n    const call = function call() {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      } // TODO Warn on deprecated methods\n      // Here, logically, it should be `of(this.formatInputs(method, values))`.\n      // However, formatInputs can throw, and when it does, the above way\n      // doesn't throw in the \"Observable loop\" (which is internally wrapped in\n      // a try/catch block). So we:\n      // - first do `of(1)` - won't throw\n      // - then do `map(()=>this.formatInputs)` - might throw, but inside Observable.\n\n\n      return (0, _rxjs.of)(1).pipe((0, _operators.map)(() => _this.formatInputs(method, values)), (0, _operators.switchMap)(params => (0, _rxjs.combineLatest)([(0, _rxjs.of)(params), (0, _rxjs.from)(_this.provider.send(rpcName, params.map(param => param.toJSON())))])), (0, _operators.map)(_ref4 => {\n        let _ref7 = _slicedToArray(_ref4, 2),\n            params = _ref7[0],\n            result = _ref7[1];\n\n        return _this.formatOutput(method, params, result);\n      }), (0, _operators.catchError)(error => {\n        const message = _this.createErrorMessage(method, error);\n\n        l.error(message);\n        return (0, _rxjs.throwError)(new _util.ExtError(message, error.code, undefined));\n      }), (0, _operators.publishReplay)(1), // create a Replay(1)\n      (0, _operators.refCount)() // Unsubcribe WS when there are no more subscribers\n      );\n    }; // We voluntarily don't cache the \"one-shot\" RPC calls. For example,\n    // `getStorage('123')` returns the current value, but this value can change\n    // over time, so we wouldn't want to cache the Observable.\n\n\n    return call;\n  }\n\n  createMethodSubscribe(method) {\n    var _this2 = this;\n\n    const _method$pubsub = _slicedToArray(method.pubsub, 3),\n          updateType = _method$pubsub[0],\n          subMethod = _method$pubsub[1],\n          unsubMethod = _method$pubsub[2];\n\n    const subName = \"\".concat(method.section, \"_\").concat(subMethod);\n    const unsubName = \"\".concat(method.section, \"_\").concat(unsubMethod);\n    const subType = \"\".concat(method.section, \"_\").concat(updateType);\n\n    const call = function call() {\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n\n      return new _rxjs.Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve();\n\n        const errorHandler = error => {\n          const message = _this2.createErrorMessage(method, error);\n\n          l.error(message);\n          observer.error(new _util.ExtError(message, error.code, undefined));\n        };\n\n        try {\n          const params = _this2.formatInputs(method, values);\n\n          const paramsJson = params.map(param => param.toJSON());\n\n          const update = (error, result) => {\n            if (error) {\n              l.error(_this2.createErrorMessage(method, error));\n              return;\n            }\n\n            observer.next(_this2.formatOutput(method, params, result));\n          }; // FIXME This is a work-around, provider.subscribe _should_ always return,\n          // however in some cases `this.provider.subscribe.catch` yields \".catch of\n          // undefined\", so here we flatten via Promise.reolve (which doe sfollow)\n\n\n          subscriptionPromise = Promise.resolve(_this2.provider.subscribe(subType, subName, paramsJson, update)).catch(errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        } // Teardown logic\n\n\n        return () => {\n          // Delete from cache\n          // Reason:\n          // ```\n          //    const s = api.query.system.accountNonce(addr1).subscribe(); // let's say it's 6\n          //    s.unsubscribe();\n          //    // wait a bit, for the nonce to increase to 7\n          //    api.query.system.accountNonce(addr1).subscribe(); // will output 6 instead of 7 if we don't clear cache\n          //    // that's because all our observables are replay(1)\n          // ```\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          memoized.delete(...values); // Unsubscribe from provider\n\n          subscriptionPromise.then(subscriptionId => (0, _util.isNumber)(subscriptionId) ? _this2.provider.unsubscribe(subType, unsubName, subscriptionId) : Promise.resolve(false)).catch(error => {\n            const message = _this2.createErrorMessage(method, error);\n\n            l.error(message);\n          });\n        };\n      }).pipe((0, _operators.publishReplay)(1), (0, _operators.refCount)());\n    };\n\n    const memoized = (0, _memoizee.default)(call, {\n      // Dynamic length for argument\n      length: false,\n      // Normalize args so that different args that should be cached\n      // together are cached together.\n      // E.g.: `query.my.method('abc') === query.my.method(new AccountId('abc'));`\n      normalizer: JSON.stringify\n    });\n    return memoized;\n  }\n\n  formatInputs(method, inputs) {\n    const reqArgCount = method.params.filter(_ref5 => {\n      let isOptional = _ref5.isOptional;\n      return !isOptional;\n    }).length;\n    const optText = reqArgCount === method.params.length ? '' : \" (\".concat(method.params.length - reqArgCount, \" optional)\");\n    (0, _util.assert)(inputs.length >= reqArgCount && inputs.length <= method.params.length, \"Expected \".concat(method.params.length, \" parameters\").concat(optText, \", \").concat(inputs.length, \" found instead\"));\n    return inputs.map((input, index) => (0, _types.createType)(method.params[index].type, input));\n  }\n\n  formatOutput(method, params, result) {\n    const base = (0, _types.createType)(method.type, result);\n\n    if (method.type === 'StorageData') {\n      const key = params[0];\n\n      try {\n        return this.formatStorageData(key, base, (0, _util.isNull)(result));\n      } catch (error) {\n        console.error(\"Unable to decode storage \".concat(key.section, \".\").concat(key.method, \":\"), error.message);\n        throw error;\n      }\n    } else if (method.type === 'StorageChangeSet') {\n      // multiple return values (via state.storage subscription), decode the values\n      // one at a time, all based on the query types. Three values can be returned -\n      //   - Base - There is a valid value, non-empty\n      //   - null - The storage key is empty (but in the resultset)\n      //   - undefined - The storage value is not in the resultset\n      return params[0].reduce((results, key) => {\n        try {\n          results.push(this.formatStorageSet(key, base));\n        } catch (error) {\n          console.error(\"Unable to decode storage \".concat(key.section, \".\").concat(key.method, \":\"), error.message);\n          throw error;\n        }\n\n        return results;\n      }, []);\n    }\n\n    return base;\n  }\n\n  formatStorageData(key, base, isNull) {\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Data on nothing\n    const type = key.outputType || 'Data';\n    const meta = key.meta || EMPTY_META;\n\n    if (meta.modifier.isOptional) {\n      return new _types.Option((0, _types.createClass)(type), isNull ? null : (0, _types.createType)(type, base, true));\n    }\n\n    return (0, _types.createType)(type, isNull ? meta.fallback : base, true);\n  }\n\n  formatStorageSet(key, base) {\n    // Fallback to Data (i.e. just the encoding) if we don't have a specific type\n    const type = key.outputType || 'Data';\n    const hexKey = key.toHex();\n    const meta = key.meta || EMPTY_META; // see if we have a result value for this specific key, fallback to the cache value\n    // when the value in the set is not available, or is null/empty.\n\n    const _ref8 = base.changes.find(_ref6 => {\n      let key = _ref6.key,\n          value = _ref6.value;\n      return value.isSome && key.toHex() === hexKey;\n    }) || {\n      value: this._storageCache.get(hexKey) || new _types.Option(_types.StorageData, null)\n    },\n          value = _ref8.value; // store the retrieved result - the only issue with this cache is that there is no\n    // clearning of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n\n\n    this._storageCache.set(hexKey, value);\n\n    if (meta.modifier.isOptional) {\n      return new _types.Option((0, _types.createClass)(type), value.isNone ? null : (0, _types.createType)(type, value.unwrap(), true));\n    }\n\n    return (0, _types.createType)(type, value.unwrapOr(meta.fallback), true);\n  }\n\n}\n\nexports.default = Rpc;","map":null,"metadata":{},"sourceType":"script"}