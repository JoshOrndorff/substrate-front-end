{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Compact = _interopRequireDefault(require(\"../../codec/Compact\"));\n\nvar _Struct = _interopRequireDefault(require(\"../../codec/Struct\"));\n\nvar _Vector = _interopRequireDefault(require(\"../../codec/Vector\"));\n\nvar _util2 = require(\"../util\");\n\nvar _Calls = require(\"./Calls\");\n\nvar _Events = require(\"./Events\");\n\nvar _Modules = require(\"./Modules\"); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n// Decodes the runtime metadata as passed through from the `state_getMetadata` call.\n\n/**\n * @name MetadataV0\n * @description\n * The runtime metadata as a decoded structure\n */\n\n\nclass MetadataV0 extends _Struct.default {\n  constructor(value) {\n    super({\n      outerEvent: _Events.OuterEventMetadata,\n      modules: _Vector.default.with(_Modules.RuntimeModuleMetadata),\n      outerDispatch: _Calls.OuterDispatchMetadata\n    }, MetadataV0.decodeMetadata(value));\n  }\n\n  static decodeMetadata(value) {\n    if ((0, _util.isHex)(value)) {\n      // We receive this as an hex in the JSON output from the Node.\n      // Convert to u8a and use the U8a version to do the actual parsing.\n      return MetadataV0.decodeMetadata((0, _util.hexToU8a)(value));\n    } else if ((0, _util.isU8a)(value)) {\n      // HACK 13 Oct 2018 - For current running BBQ nodes, Metadata is not properly\n      // encoded, it does not have a length prefix. For latest substrate master, it\n      // is properly encoded. Here we pull the prefix, check it agianst the length -\n      // if matches, then we have the length, otherwise we assume it is an older node\n      // and use the whole buffer\n      const _Compact$default$deco = _Compact.default.decodeU8a(value),\n            _Compact$default$deco2 = _slicedToArray(_Compact$default$deco, 2),\n            offset = _Compact$default$deco2[0],\n            length = _Compact$default$deco2[1];\n\n      return value.length === offset + length.toNumber() ? value.subarray(offset) : value;\n    } // Decode as normal struct\n\n\n    return value;\n  }\n  /**\n   * @description Wrapped [[OuterDispatchCall]]\n   */\n\n\n  get calls() {\n    return this.get('outerDispatch').calls;\n  }\n  /**\n   * @description Wrapped [[OuterEventEventMetadata]]\n   */\n\n\n  get events() {\n    return this.get('outerEvent').events;\n  }\n  /**\n   * @description Wrapped [[RuntimeModuleMetadata]]\n   */\n\n\n  get modules() {\n    return this.get('modules');\n  }\n\n  get argNames() {\n    return this.modules.map(modul => modul.module.call.functions.map(fn => fn.args.map(argument => argument.type.toString())));\n  }\n\n  get eventNames() {\n    return this.events.map(modul => modul.events.map(event => event.args.map(argument => argument.toString())));\n  }\n\n  get storageNames() {\n    return this.modules.map(modul => modul.storage.isSome ? modul.storage.unwrap().functions.map(fn => fn.type.isMap ? [fn.type.asMap.key.toString(), fn.type.asMap.value.toString()] : [fn.type.asType.toString()]) : []);\n  }\n  /**\n   * @description Helper to retrieve a list of all type that are found, sorted and de-deuplicated\n   */\n\n\n  getUniqTypes(throwError) {\n    const types = (0, _util2.flattenUniq)([this.argNames, this.eventNames, this.storageNames]);\n    (0, _util2.validateTypes)(types, throwError);\n    return types;\n  }\n\n}\n\nexports.default = MetadataV0;","map":null,"metadata":{},"sourceType":"script"}