{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  derive: true\n};\nexports.default = decorateDerive;\nexports.derive = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar accounts = _interopRequireWildcard(require(\"./accounts\"));\n\nvar balances = _interopRequireWildcard(require(\"./balances\"));\n\nvar chain = _interopRequireWildcard(require(\"./chain\"));\n\nvar contracts = _interopRequireWildcard(require(\"./contracts\"));\n\nvar democracy = _interopRequireWildcard(require(\"./democracy\"));\n\nvar elections = _interopRequireWildcard(require(\"./elections\"));\n\nvar session = _interopRequireWildcard(require(\"./session\"));\n\nvar staking = _interopRequireWildcard(require(\"./staking\"));\n\nvar _type = require(\"./type\");\n\nObject.keys(_type).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _type[key];\n    }\n  });\n});\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * Returns an object that will inject `api` into all the functions inside\n * `allSections`, and keep the object architecture of `allSections`.\n */\n\n\nfunction injectFunctions(api, allSections) {\n  return Object.keys(allSections).reduce((deriveAcc, sectionName) => {\n    const section = allSections[sectionName];\n    deriveAcc[sectionName] = Object.keys(section).reduce((sectionAcc, _methodName) => {\n      const methodName = _methodName; // Not sure what to do here, casting as any. Though the final types are good\n\n      const method = section[methodName](api); // idem\n\n      sectionAcc[methodName] = method;\n      return sectionAcc;\n    }, {});\n    return deriveAcc;\n  }, {});\n}\n\nconst derive = {\n  accounts,\n  balances,\n  chain,\n  contracts,\n  democracy,\n  elections,\n  session,\n  staking\n};\nexports.derive = derive; // FIXME I have no idea how to get this done\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\nfunction decorateDerive(api) {\n  let custom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _objectSpread({}, injectFunctions(api, derive), {}, injectFunctions(api, custom));\n}","map":null,"metadata":{},"sourceType":"script"}