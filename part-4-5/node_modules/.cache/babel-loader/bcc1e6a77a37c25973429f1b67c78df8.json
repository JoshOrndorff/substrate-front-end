{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _defaults = require(\"./defaults\");\n\nvar _pair = _interopRequireDefault(require(\"./pair\"));\n\nvar _pairs = _interopRequireDefault(require(\"./pairs\")); // Copyright 2017-2019 @polkadot/keyring authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\n\n\nclass Keyring {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._pairs = void 0;\n    this._type = void 0;\n    this.decodeAddress = _utilCrypto.decodeAddress;\n    this.encodeAddress = _utilCrypto.encodeAddress;\n    this.setAddressPrefix = _utilCrypto.setAddressPrefix;\n    options.type = options.type || 'ed25519';\n    (0, _util.assert)(options && ['ed25519', 'sr25519'].includes(options.type || 'undefined'), \"Expected a keyring type of either 'ed25519' or 'sr25519', found '\".concat(options.type));\n    this._pairs = new _pairs.default();\n    this._type = options.type;\n    (0, _utilCrypto.setAddressPrefix)((0, _util.isNumber)(options.addressPrefix) ? options.addressPrefix : 42);\n  }\n  /**\n   * @description retrieve the pairs (alias for getPairs)\n   */\n\n\n  get pairs() {\n    return this.getPairs();\n  }\n  /**\n   * @description retrieve the publicKeys (alias for getPublicKeys)\n   */\n\n\n  get publicKeys() {\n    return this.getPublicKeys();\n  }\n  /**\n   * @description Returns the type of the keyring, either ed25519 of sr25519\n   */\n\n\n  get type() {\n    return this._type;\n  }\n  /**\n   * @name addPair\n   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   */\n\n\n  addPair(pair) {\n    return this._pairs.add(pair);\n  }\n  /**\n   * @name addFromAddress\n   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to explicitely provide separate inputs including account address or public key, and optionally\n   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from them that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromAddress(address) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let encoded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.type;\n    let ignoreChecksum = arguments.length > 4 ? arguments[4] : undefined;\n    const publicKey = this.decodeAddress(address, ignoreChecksum);\n    return this.addPair((0, _pair.default)(type, {\n      publicKey\n    }, meta, encoded));\n  }\n  /**\n   * @name addFromJson\n   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromJson(_ref, ignoreChecksum) {\n    let address = _ref.address,\n        encoded = _ref.encoded,\n        _ref$encoding = _ref.encoding,\n        content = _ref$encoding.content,\n        version = _ref$encoding.version,\n        meta = _ref.meta;\n    const type = version === '0' || !Array.isArray(content) ? this.type : content[1];\n    return this.addFromAddress(address, meta, (0, _util.hexToU8a)(encoded), type, ignoreChecksum);\n  }\n  /**\n   * @name addFromMnemonic\n   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n   * argument and a metadata argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromMnemonic(mnemonic) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n    return this.addFromUri(mnemonic, meta, type);\n  }\n  /**\n   * @name addFromSeed\n   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromSeed(seed) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n    const keypair = type === 'sr25519' ? (0, _utilCrypto.schnorrkelKeypairFromSeed)(seed) : (0, _utilCrypto.naclKeypairFromSeed)(seed);\n    return this.addPair((0, _pair.default)(type, keypair, meta, null));\n  }\n  /**\n   * @name addFromUri\n   * @summary Creates an account via an suri\n   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n   */\n\n\n  addFromUri(suri) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type;\n    return this.addPair(this.createFromUri(suri, meta, type));\n  }\n  /**\n   * @name createFromUri\n   * @summry Creates a Keypair from an suri\n   * @description This creates a pair from the suri, but does not add it to the keyring\n   */\n\n\n  createFromUri(_suri) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.type; // here we only aut-add the dev phrase if we have a hard-derived path\n\n    const suri = _suri.indexOf('//') === 0 ? \"\".concat(_defaults.DEV_PHRASE).concat(_suri) : _suri;\n\n    const _ref3 = (0, _utilCrypto.keyExtractSuri)(suri),\n          password = _ref3.password,\n          phrase = _ref3.phrase,\n          path = _ref3.path;\n\n    let seed;\n\n    if ((0, _util.isHex)(phrase, 256)) {\n      seed = (0, _util.hexToU8a)(phrase);\n    } else {\n      const str = phrase;\n      const parts = str.split(' ');\n\n      if ([12, 15, 18, 21, 24].includes(parts.length)) {\n        // FIXME This keeps compat with older versions, but breaks compat with subkey\n        // seed = type === 'sr25519'\n        //   ? mnemonicToMiniSecret(phrase, password)\n        //   : mnemonicToSeed(phrase, password);\n        seed = (0, _utilCrypto.mnemonicToMiniSecret)(phrase, password);\n      } else {\n        (0, _util.assert)(str.length <= 32, 'specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n        seed = (0, _util.stringToU8a)(str.padEnd(32));\n      }\n    }\n\n    const keypair = type === 'sr25519' ? (0, _utilCrypto.schnorrkelKeypairFromSeed)(seed) : (0, _utilCrypto.naclKeypairFromSeed)(seed);\n    const derived = (0, _utilCrypto.keyFromPath)(keypair, path, type);\n    return (0, _pair.default)(type, derived, meta, null);\n  }\n  /**\n   * @name getPair\n   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n   * @description Returns a keyring pair value from the keyring pair dictionary by performing\n   * a key lookup using the provided account address or public key (after decoding it).\n   */\n\n\n  getPair(address) {\n    return this._pairs.get(address);\n  }\n  /**\n   * @name getPairs\n   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPairs() {\n    return this._pairs.all();\n  }\n  /**\n   * @name getPublicKeys\n   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPublicKeys() {\n    return this._pairs.all().map(_ref2 => {\n      let publicKey = _ref2.publicKey;\n      return publicKey;\n    });\n  }\n  /**\n   * @name removePair\n   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n   */\n\n\n  removePair(address) {\n    this._pairs.remove(address);\n  }\n  /**\n   * @name toJson\n   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n   * @description Returns a JSON object containing the metadata associated with an account\n   * when valid address or public key and when the account passphrase is provided if the account secret\n   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n   * may backup their account to a JSON file that contains this information.\n   */\n\n\n  toJson(address, passphrase) {\n    return this._pairs.get(address).toJson(passphrase);\n  }\n\n}\n\nexports.default = Keyring;","map":null,"metadata":{},"sourceType":"script"}