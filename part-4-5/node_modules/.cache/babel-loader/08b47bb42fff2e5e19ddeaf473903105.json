{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeSplit = typeSplit;\nexports.getTypeDef = getTypeDef;\nexports.createClass = createClass;\nexports.getTypeClassMap = getTypeClassMap;\nexports.getTypeClass = getTypeClass;\nexports.ClassOf = ClassOf;\nexports.default = createType;\nexports.TypeDefInfo = void 0;\n\nvar _memoizee = _interopRequireDefault(require(\"memoizee\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Null = _interopRequireDefault(require(\"../primitive/Null\"));\n\nvar _StorageData = _interopRequireDefault(require(\"../primitive/StorageData\"));\n\nvar _Compact = _interopRequireDefault(require(\"./Compact\"));\n\nvar _Enum = _interopRequireDefault(require(\"./Enum\"));\n\nvar _Linkage = _interopRequireDefault(require(\"./Linkage\"));\n\nvar _Option = _interopRequireDefault(require(\"./Option\"));\n\nvar _Struct = _interopRequireDefault(require(\"./Struct\"));\n\nvar _Tuple = _interopRequireDefault(require(\"./Tuple\"));\n\nvar _U8aFixed = _interopRequireDefault(require(\"./U8aFixed\"));\n\nvar _Vector = _interopRequireDefault(require(\"./Vector\"));\n\nvar _VectorFixed = _interopRequireDefault(require(\"./VectorFixed\"));\n\nvar _typeRegistry = _interopRequireDefault(require(\"./typeRegistry\")); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nlet TypeDefInfo;\nexports.TypeDefInfo = TypeDefInfo;\n\n(function (TypeDefInfo) {\n  TypeDefInfo[TypeDefInfo[\"Compact\"] = 0] = \"Compact\";\n  TypeDefInfo[TypeDefInfo[\"DoubleMap\"] = 1] = \"DoubleMap\";\n  TypeDefInfo[TypeDefInfo[\"Enum\"] = 2] = \"Enum\";\n  TypeDefInfo[TypeDefInfo[\"Linkage\"] = 3] = \"Linkage\";\n  TypeDefInfo[TypeDefInfo[\"Option\"] = 4] = \"Option\";\n  TypeDefInfo[TypeDefInfo[\"Plain\"] = 5] = \"Plain\";\n  TypeDefInfo[TypeDefInfo[\"Struct\"] = 6] = \"Struct\";\n  TypeDefInfo[TypeDefInfo[\"Tuple\"] = 7] = \"Tuple\";\n  TypeDefInfo[TypeDefInfo[\"Vector\"] = 8] = \"Vector\";\n  TypeDefInfo[TypeDefInfo[\"VectorFixed\"] = 9] = \"VectorFixed\";\n  TypeDefInfo[TypeDefInfo[\"Null\"] = 10] = \"Null\";\n})(TypeDefInfo || (exports.TypeDefInfo = TypeDefInfo = {})); // safely split a string on ', ' while taking care of any nested occurences\n\n\nfunction typeSplit(type) {\n  let cDepth = 0; // compact/doublemap/linkedmap/option/vector depth\n\n  let fDepth = 0; // vector (fixed) depth\n\n  let sDepth = 0; // struct depth\n\n  let tDepth = 0; // tuple depth\n\n  let start = 0;\n  const result = [];\n\n  for (let index = 0; index < type.length; index++) {\n    switch (type[index]) {\n      case ',':\n        // we are not nested, add the type\n        if (cDepth === 0 && fDepth === 0 && sDepth === 0 && tDepth === 0) {\n          result.push(type.substr(start, index - start).trim());\n          start = index + 1;\n        }\n\n        break;\n      // adjust compact/vec (and friends) depth\n\n      case '<':\n        cDepth++;\n        break;\n\n      case '>':\n        cDepth--;\n        break;\n      // adjust fixed vec depths\n\n      case '[':\n        fDepth++;\n        break;\n\n      case ']':\n        fDepth--;\n        break;\n      // adjust struct depth\n\n      case '{':\n        sDepth++;\n        break;\n\n      case '}':\n        sDepth--;\n        break;\n      // adjusttuple depth\n\n      case '(':\n        tDepth++;\n        break;\n\n      case ')':\n        tDepth--;\n        break;\n      // normal character\n\n      default:\n        break;\n    }\n  }\n\n  (0, _util.assert)(!cDepth && !fDepth && !sDepth && !tDepth, \"Invalid defintion (missing terminators) found in \".concat(type)); // the final leg of the journey\n\n  result.push(type.substr(start, type.length - start).trim());\n  return result;\n}\n\nfunction getTypeDef(_type, name) {\n  const type = _type.toString().trim();\n\n  const value = {\n    info: TypeDefInfo.Plain,\n    name,\n    type\n  };\n  let subType = '';\n\n  const startingWith = (type, start, end) => {\n    if (type.substr(0, start.length) !== start) {\n      return false;\n    }\n\n    (0, _util.assert)(type[type.length - 1] === end, \"Expected '\".concat(start, \"' closing with '\").concat(end, \"'\"));\n    subType = type.substr(start.length, type.length - start.length - 1);\n    return true;\n  };\n\n  if (startingWith(type, '(', ')')) {\n    value.info = TypeDefInfo.Tuple;\n    value.sub = typeSplit(subType).map(inner => getTypeDef(inner));\n  } else if (startingWith(type, '[', ']')) {\n    // this handles e.g. [u8;32]\n    const _type$substr$split = type.substr(1, type.length - 2).split(';'),\n          _type$substr$split2 = _slicedToArray(_type$substr$split, 2),\n          vecType = _type$substr$split2[0],\n          _vecLen = _type$substr$split2[1];\n\n    const vecLen = parseInt(_vecLen.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n    (0, _util.assert)(vecLen <= 256, \"\".concat(type, \": Only support for [Type; <length>], where length <= 256\"));\n    value.info = TypeDefInfo.VectorFixed;\n    value.ext = {\n      length: vecLen,\n      type: vecType\n    };\n  } else if (startingWith(type, '{', '}')) {\n    const parsed = JSON.parse(type);\n    const keys = Object.keys(parsed);\n\n    if (keys.length === 1 && keys[0] === '_enum') {\n      const details = parsed[keys[0]]; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n      value.sub = Array.isArray(details) ? details.map(name => ({\n        info: TypeDefInfo.Plain,\n        name,\n        type: 'Null'\n      })) : Object.keys(details).map(name => ({\n        info: TypeDefInfo.Plain,\n        name,\n        type: details[name] || 'Null'\n      }));\n      value.info = TypeDefInfo.Enum;\n    } else {\n      value.info = TypeDefInfo.Struct;\n      value.sub = keys.map(name => getTypeDef(parsed[name], name));\n    }\n  } else if (startingWith(type, 'Compact<', '>')) {\n    value.info = TypeDefInfo.Compact;\n    value.sub = getTypeDef(subType);\n  } else if (startingWith(type, 'Option<', '>')) {\n    value.info = TypeDefInfo.Option;\n    value.sub = getTypeDef(subType);\n  } else if (startingWith(type, 'Vec<', '>')) {\n    value.info = TypeDefInfo.Vector;\n    value.sub = getTypeDef(subType);\n  } else if (startingWith(type, 'Linkage<', '>')) {\n    value.info = TypeDefInfo.Linkage;\n    value.sub = getTypeDef(subType);\n  } else if (startingWith(type, 'DoubleMap<', '>')) {\n    value.info = TypeDefInfo.DoubleMap;\n    value.sub = getTypeDef(subType);\n  }\n\n  return value;\n} // Memoized helper of the `createClass` function below\n\n\nconst memoizedCreateClass = (0, _memoizee.default)(type => {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return getTypeClass(getTypeDef(type));\n}, {\n  length: 1,\n  // Normalize args so that different args that should be cached\n  // together are cached together.\n  // E.g.: `createClass('abc') === createClass(new Text('abc'));`\n  normalizer: JSON.stringify\n});\n\nfunction createClass(type) {\n  return memoizedCreateClass(type);\n} // create an array of constructors from the input\n\n\nfunction getTypeClassMap(defs) {\n  return defs.reduce((result, sub) => {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    result[sub.name] = getTypeClass(sub);\n    return result;\n  }, {});\n} // Returns the type Class for construction\n\n\nfunction getTypeClass(value, Fallback) {\n  const Type = (0, _typeRegistry.default)().get(value.type);\n\n  if (Type) {\n    return Type;\n  }\n\n  switch (value.info) {\n    case TypeDefInfo.Compact:\n      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for Compact');\n      return _Compact.default.with(getTypeClass(value.sub));\n\n    case TypeDefInfo.Enum:\n      (0, _util.assert)(value.sub && Array.isArray(value.sub), 'Expected subtype for Enum');\n      return _Enum.default.with(getTypeClassMap(value.sub));\n\n    case TypeDefInfo.Option:\n      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for Option');\n      return _Option.default.with(getTypeClass(value.sub));\n\n    case TypeDefInfo.Struct:\n      (0, _util.assert)(Array.isArray(value.sub), 'Expected nested subtypes for Struct');\n      return _Struct.default.with(getTypeClassMap(value.sub));\n\n    case TypeDefInfo.Tuple:\n      (0, _util.assert)(Array.isArray(value.sub), 'Expected nested subtypes for Tuple');\n      return _Tuple.default.with(value.sub.map(Type => getTypeClass(Type)));\n\n    case TypeDefInfo.Vector:\n      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for Vector');\n      return _Vector.default.with(getTypeClass(value.sub));\n\n    case TypeDefInfo.VectorFixed:\n      (0, _util.assert)(value.ext, 'Expected length & type information for fixed vector');\n      const ext = value.ext;\n      return ext.type === 'u8' ? _U8aFixed.default.with(ext.length * 8) : _VectorFixed.default.with(createClass(ext.type), ext.length);\n\n    case TypeDefInfo.Linkage:\n      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for Linkage');\n      return _Linkage.default.withKey(getTypeClass(value.sub));\n\n    case TypeDefInfo.DoubleMap:\n      (0, _util.assert)(value.sub && !Array.isArray(value.sub), 'Expected subtype for DoubleMap');\n      return getTypeClass(value.sub);\n\n    case TypeDefInfo.Null:\n      return _Null.default;\n  }\n\n  if (Fallback) {\n    return Fallback;\n  }\n\n  throw new Error(\"Unable to determine type from '\".concat(value.type, \"'\"));\n} // alias for createClass\n\n\nfunction ClassOf(name) {\n  return createClass(name);\n}\n\nfunction initType(Type, value, isPedantic) {\n  try {\n    const created = new Type(value); // in pedantic mode, actually check that the encoding matches that supplied - this\n    // is much slower, but ensures that we have a 100% grasp on the actual provided value\n\n    if (isPedantic && value && value.toHex && value.toU8a) {\n      const inHex = value.toHex(true);\n      const crHex = created.toHex(true);\n      (0, _util.assert)(inHex === crHex || // check that the hex matches, if matching, all-ok\n      value instanceof _StorageData.default && // input is from storage\n      created instanceof Uint8Array && // we are a variable-lneght structure\n      value.toU8a(true).toString() === created.toU8a().toString() // strip the input length\n      , \"Input doesn't match output, received \".concat(inHex, \", created \").concat(crHex));\n    }\n\n    return created;\n  } catch (error) {\n    if (Type.Fallback) {\n      return initType(Type.Fallback, value, isPedantic);\n    }\n\n    throw error;\n  }\n}\n\nfunction createType(type, value, isPedantic) {\n  // l.debug(() => ['createType', { type, value }]);\n  try {\n    return initType(createClass(type), value, isPedantic);\n  } catch (error) {\n    throw new Error(\"createType(\".concat(type, \"):: \").concat(error.message));\n  }\n}","map":null,"metadata":{},"sourceType":"script"}