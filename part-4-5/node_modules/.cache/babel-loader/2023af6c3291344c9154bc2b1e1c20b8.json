{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _defaults = require(\"@polkadot/util/compact/defaults\");\n\nvar _Base = _interopRequireDefault(require(\"./Base\")); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name Compact\n * @description\n * A compact length-encoding codec wrapper. It performs the same function as Length, however\n * differs in that it uses a variable number of bytes to do the actual encoding. This is mostly\n * used by other types to add length-prefixed encoding, or in the case of wrapped types, taking\n * a number and making the compact representation thereof\n */\n\n\nclass Compact extends _Base.default {\n  constructor(Type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    super(Compact.decodeCompact(Type, value));\n  }\n\n  static with(Type) {\n    return class extends Compact {\n      constructor(value) {\n        super(Type, value);\n      }\n\n    };\n  }\n  /**\n   * Prepend a Uint8Array with its compact length.\n   *\n   * @param u8a - The Uint8Array to be prefixed\n   */\n\n\n  static stripLengthPrefix(u8a) {\n    let bitLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaults.DEFAULT_BITLENGTH;\n\n    const _ref = (0, _util.compactStripLength)(u8a, bitLength),\n          _ref2 = _slicedToArray(_ref, 2),\n          value = _ref2[1];\n\n    return value;\n  }\n\n  static decodeCompact(Type, value) {\n    if (value instanceof Compact) {\n      return new Type(value.raw);\n    } else if ((0, _util.isString)(value)) {\n      return new Type((0, _util.isHex)(value, -1, true) ? (0, _util.hexToBn)(value) : new _bn.default(value, 10));\n    } else if ((0, _util.isNumber)(value) || (0, _util.isBn)(value)) {\n      return new Type((0, _util.bnToBn)(value));\n    }\n\n    const _Compact$decodeU8a = Compact.decodeU8a(value, new Type(0).bitLength()),\n          _Compact$decodeU8a2 = _slicedToArray(_Compact$decodeU8a, 2),\n          _value = _Compact$decodeU8a2[1];\n\n    return new Type(_value);\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n\n\n  bitLength() {\n    return this.raw.bitLength();\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return this.raw.eq(other instanceof Compact ? other.raw : other);\n  }\n  /**\n   * @description Returns the BN representation of the number\n   */\n\n\n  toBn() {\n    return this.raw.toBn();\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n\n\n  toNumber() {\n    return this.raw.toNumber();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return \"Compact<\".concat(this.raw.toRawType(), \">\");\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    return Compact.encodeU8a(this.raw.toBn());\n  }\n  /**\n   * @description Returns the embedded [[UInt]] or [[Moment]] value\n   */\n\n\n  unwrap() {\n    return this.raw;\n  }\n\n}\n\nexports.default = Compact;\nCompact.addLengthPrefix = _util.compactAddLength;\nCompact.decodeU8a = _util.compactFromU8a;\nCompact.encodeU8a = _util.compactToU8a;","map":null,"metadata":{},"sourceType":"script"}