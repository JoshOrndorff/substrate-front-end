{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.MethodIndex = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _createType = require(\"../codec/createType\");\n\nvar _Struct = _interopRequireDefault(require(\"../codec/Struct\"));\n\nvar _U8aFixed = _interopRequireDefault(require(\"../codec/U8aFixed\"));\n\nvar _Hash = _interopRequireDefault(require(\"./Hash\")); // Copyright 2017-2019 @polkadot/api-metadata authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst FN_UNKNOWN = {\n  method: 'unknown',\n  section: 'unknown'\n};\nconst injected = {};\n/**\n * @name MethodIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\n\nclass MethodIndex extends _U8aFixed.default {\n  constructor(value) {\n    super(value, 16);\n  }\n\n}\n/**\n * @name Method\n * @description\n * Extrinsic function descriptor, as defined in\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n */\n\n\nexports.MethodIndex = MethodIndex;\n\nclass Method extends _Struct.default {\n  constructor(value, meta) {\n    const decoded = Method.decodeMethod(value, meta);\n    super({\n      callIndex: MethodIndex,\n      args: _Struct.default.with(decoded.argsDef)\n    }, decoded);\n    this._meta = void 0;\n    this._meta = decoded.meta;\n  }\n  /**\n   * Decode input to pass into constructor.\n   *\n   * @param value - Value to decode, one of:\n   * - hex\n   * - Uint8Array\n   * - {@see DecodeMethodInput}\n   * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n   * necessary.\n   */\n\n\n  static decodeMethod() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n\n    let _meta = arguments.length > 1 ? arguments[1] : undefined;\n\n    if ((0, _util.isHex)(value)) {\n      return Method.decodeMethod((0, _util.hexToU8a)(value), _meta);\n    } else if ((0, _util.isU8a)(value)) {\n      // The first 2 bytes are the callIndex\n      const callIndex = value.subarray(0, 2); // Find metadata with callIndex\n\n      const meta = _meta || Method.findFunction(callIndex).meta;\n\n      return {\n        args: value.subarray(2),\n        argsDef: Method.getArgsDef(meta),\n        callIndex,\n        meta\n      };\n    } else if ((0, _util.isObject)(value) && value.callIndex && value.args) {\n      // destructure value, we only pass args/methodsIndex out\n      const args = value.args,\n            callIndex = value.callIndex; // Get the correct lookupIndex\n\n      const lookupIndex = callIndex instanceof MethodIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex\n\n      const meta = _meta || Method.findFunction(lookupIndex).meta;\n\n      return {\n        args,\n        argsDef: Method.getArgsDef(meta),\n        meta,\n        callIndex\n      };\n    }\n\n    throw new Error(\"Method: Cannot decode value '\".concat(value, \"' of type \").concat(typeof value));\n  } // If the extrinsic function has an argument of type `Origin`, we ignore it\n\n\n  static filterOrigin(meta) {\n    // FIXME should be `arg.type !== Origin`, but doesn't work...\n    return meta ? meta.args.filter(_ref => {\n      let type = _ref.type;\n      return type.toString() !== 'Origin';\n    }) : [];\n  } // We could only inject the meta (see injectMethods below) and then do a\n  // meta-only lookup via\n  //\n  //   metadata.modules[callIndex[0]].module.call.functions[callIndex[1]]\n  //\n  // As a convenience helper though, we return the full constructor function,\n  // which includes the meta, name, section & actual interface for calling\n\n\n  static findFunction(callIndex) {\n    (0, _util.assert)(Object.keys(injected).length > 0, 'Calling Method.findFunction before extrinsics have been injected.');\n    return injected[callIndex.toString()] || FN_UNKNOWN;\n  }\n  /**\n   * Get a mapping of `argument name -> argument type` for the function, from\n   * its metadata.\n   *\n   * @param meta - The function metadata used to get the definition.\n   */\n\n\n  static getArgsDef(meta) {\n    return Method.filterOrigin(meta).reduce((result, _ref2) => {\n      let name = _ref2.name,\n          type = _ref2.type;\n      const Type = (0, _createType.getTypeClass)((0, _createType.getTypeDef)(type));\n      result[name.toString()] = Type;\n      return result;\n    }, {});\n  } // This is called/injected by the API on init, allowing a snapshot of\n  // the available system extrinsics to be used in lookups\n\n\n  static injectMethods(moduleMethods) {\n    Object.values(moduleMethods).forEach(methods => Object.values(methods).forEach(method => {\n      injected[method.callIndex.toString()] = method;\n    }));\n  }\n  /**\n   * @description The arguments for the function call\n   */\n\n\n  get args() {\n    // FIXME This should return a Struct instead of an Array\n    return [...this.get('args').values()];\n  }\n  /**\n   * @description Thge argument defintions\n   */\n\n\n  get argsDef() {\n    return Method.getArgsDef(this.meta);\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n\n\n  get callIndex() {\n    return this.get('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n\n\n  get data() {\n    return this.get('args').toU8a();\n  }\n  /**\n   * @description Convenience function, encodes the Method and returns the actual hash\n   */\n\n\n  get hash() {\n    return new _Hash.default((0, _utilCrypto.blake2AsU8a)(this.toU8a(), 256));\n  }\n  /**\n   * @description `true` if the `Origin` type is on the method (extrinsic method)\n   */\n\n\n  get hasOrigin() {\n    const firstArg = this.meta.args[0];\n    return !!firstArg && firstArg.type.toString() === 'Origin';\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get methodName() {\n    return Method.findFunction(this.callIndex).method;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get sectionName() {\n    return Method.findFunction(this.callIndex).section;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Call';\n  }\n\n}\n\nexports.default = Method;","map":null,"metadata":{},"sourceType":"script"}