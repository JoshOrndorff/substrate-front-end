{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ACCOUNT_ID_PREFIX = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Base = _interopRequireDefault(require(\"../codec/Base\"));\n\nvar _AccountId = _interopRequireDefault(require(\"./AccountId\"));\n\nvar _AccountIndex = _interopRequireDefault(require(\"./AccountIndex\")); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/**\n * @name Address\n * @description\n * A wrapper around an AccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\n\nexports.ACCOUNT_ID_PREFIX = ACCOUNT_ID_PREFIX;\n\nclass Address extends _Base.default {\n  constructor() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    super(Address.decodeAddress(value));\n  }\n\n  static decodeAddress(value) {\n    if (value instanceof _AccountId.default || value instanceof _AccountIndex.default) {\n      return value;\n    } else if ((0, _util.isBn)(value) || (0, _util.isNumber)(value)) {\n      return new _AccountIndex.default(value);\n    } else if (value instanceof Address) {\n      return value.raw;\n    } else if (Array.isArray(value)) {\n      return Address.decodeAddress((0, _util.u8aToU8a)(value));\n    } else if ((0, _util.isU8a)(value)) {\n      // This allows us to instantiate an address with a raw publicKey. Do this first before\n      // we checking the first byte, otherwise we may split an already-existent valid address\n      if (value.length === 32) {\n        return new _AccountId.default(value);\n      } else if (value[0] === 0xff) {\n        return new _AccountId.default(value.subarray(1));\n      }\n\n      const _AccountIndex$default = _AccountIndex.default.readLength(value),\n            _AccountIndex$default2 = _slicedToArray(_AccountIndex$default, 2),\n            offset = _AccountIndex$default2[0],\n            length = _AccountIndex$default2[1];\n\n      return new _AccountIndex.default((0, _util.u8aToBn)(value.subarray(offset, offset + length), true));\n    } else if ((0, _util.isHex)(value)) {\n      return Address.decodeAddress((0, _util.hexToU8a)(value));\n    }\n\n    const decoded = (0, _utilCrypto.decodeAddress)(value);\n    return decoded.length === 32 ? new _AccountId.default(decoded) : new _AccountIndex.default((0, _util.u8aToBn)(decoded, true));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    const rawLength = this.rawLength;\n    return rawLength + ( // for 1 byte AccountIndexes, we are not adding a specific prefix\n    rawLength > 1 ? 1 : 0);\n  }\n  /**\n   * @description The length of the raw value, either AccountIndex or AccountId\n   */\n\n\n  get rawLength() {\n    return this.raw instanceof _AccountIndex.default ? _AccountIndex.default.calcLength(this.raw) : this.raw.encodedLength;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return (0, _util.u8aToHex)(this.toU8a());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Address';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = this.raw.toU8a().subarray(0, this.rawLength);\n    return isBare ? encoded : (0, _util.u8aConcat)(this.raw instanceof _AccountIndex.default ? _AccountIndex.default.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);\n  }\n\n}\n\nexports.default = Address;","map":null,"metadata":{},"sourceType":"script"}