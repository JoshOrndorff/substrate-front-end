{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Base = _interopRequireDefault(require(\"../../codec/Base\"));\n\nvar _BalanceCompact = _interopRequireDefault(require(\"../BalanceCompact\"));\n\nvar _SignaturePayload = _interopRequireDefault(require(\"./v1/SignaturePayload\"));\n\nvar _SignaturePayload2 = _interopRequireDefault(require(\"./v2/SignaturePayload\"));\n\nvar _constants = require(\"./constants\"); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name SignaturePayload\n * @description\n * A signing payload for an [[Extrinsic]]. For the final encoding, it is variable length based\n * on the contents included\n */\n\n\nclass SignaturePayload extends _Base.default {\n  constructor(value) {\n    let _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        version = _ref.version;\n\n    super(SignaturePayload.decodeSignaturePayload(value, version));\n  }\n\n  static decodeSignaturePayload(value) {\n    let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.DEFAULT_VERSION;\n\n    if (value instanceof SignaturePayload) {\n      return value.raw;\n    }\n\n    switch (version) {\n      case 1:\n        return new _SignaturePayload.default(value);\n\n      case 2:\n        return new _SignaturePayload2.default(value);\n\n      default:\n        throw new Error(\"Unsupported extrinsic version \".concat(version));\n    }\n  }\n  /**\n   * @description The block [[Hash]] the signature applies to (mortal/immortal)\n   */\n\n\n  get blockHash() {\n    return this.raw.blockHash;\n  }\n  /**\n   * @description The [[U8a]] contained in the payload\n   */\n\n\n  get method() {\n    return this.raw.method;\n  }\n  /**\n   * @description The [[ExtrinsicEra]]\n   */\n\n\n  get era() {\n    return this.raw.era;\n  }\n  /**\n   * @description The [[NonceCompact]]\n   */\n\n\n  get nonce() {\n    return this.raw.nonce;\n  }\n  /**\n   * @description The [[BalanceCompact]]\n   */\n\n\n  get tip() {\n    return this.raw.tip || new _BalanceCompact.default(0);\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return this.raw.eq(other);\n  }\n  /**\n   * @description Sign the payload with the keypair\n   */\n\n\n  sign(signerPair) {\n    const signature = this.raw.sign(signerPair); // This is extensible, so we could quite readily extend to send back extra\n    // information, such as for instance the payload, i.e. `payload: this.toHex()`\n    // For the case here we sign via the extrinsic, we ignore the return, so generally\n    // thisis applicable for external signing\n\n    return {\n      signature: (0, _util.u8aToHex)(signature)\n    };\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.toHex();\n  }\n\n}\n\nexports.default = SignaturePayload;","map":null,"metadata":{},"sourceType":"script"}