{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MomentOf = exports.default = void 0;\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _util = require(\"@polkadot/util\"); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst BITLENGTH = 64;\n/**\n * @name Moment\n * @description\n * A wrapper around seconds/timestamps. Internally the representation only has\n * second precicion (aligning with Rust), so any numbers passed an/out are always\n * per-second. For any encoding/decoding the 1000 multiplier would be applied to\n * get it in line with JavaScript formats. It extends the base JS `Date` object\n * and has all the methods available that are applicable to any `Date`\n * @noInheritDoc\n */\n\nclass Moment extends Date {\n  // FIXME Remove this once we convert all types out of Base\n  constructor() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    super(Moment.decodeMoment(value));\n    this.raw = void 0;\n    this.raw = this;\n  }\n\n  static decodeMoment(value) {\n    if (value instanceof Date) {\n      return value;\n    } else if ((0, _util.isU8a)(value)) {\n      value = (0, _util.u8aToBn)(value.subarray(0, BITLENGTH / 8), true);\n    } else if ((0, _util.isString)(value)) {\n      value = new _bn.default(value, 10, 'le');\n    }\n\n    return new Date((0, _util.bnToBn)(value).toNumber() * 1000);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return BITLENGTH / 8;\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return this.getTime() === 0;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return Moment.decodeMoment(other).getTime() === this.getTime();\n  }\n  /**\n   * @description Returns the number of bits in the value\n   */\n\n\n  bitLength() {\n    return BITLENGTH;\n  }\n  /**\n   * @description Returns the BN representation of the timestamp\n   */\n\n\n  toBn() {\n    return new _bn.default(this.toNumber());\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    let isLe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return (0, _util.bnToHex)(this.toBn(), {\n      bitLength: BITLENGTH,\n      isLe,\n      isNegative: false\n    });\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    // FIXME Return type should be number, but conflicts with Date.toJSON()\n    // which returns string\n    return this.toNumber();\n  }\n  /**\n   * @description Returns the number representation for the timestamp\n   */\n\n\n  toNumber() {\n    return Math.ceil(this.getTime() / 1000);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Moment';\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    // only included here since we do not inherit docs\n    return super.toString();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    return (0, _util.bnToU8a)(this.toNumber(), BITLENGTH, true);\n  }\n\n}\n/**\n * @name MomentOf\n * @description\n * The Substrate MomentOf representation as a [[Moment]].\n */\n\n\nexports.default = Moment;\n\nclass MomentOf extends Moment {}\n\nexports.MomentOf = MomentOf;","map":null,"metadata":{},"sourceType":"script"}