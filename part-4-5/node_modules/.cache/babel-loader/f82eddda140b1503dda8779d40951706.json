{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Compact = _interopRequireDefault(require(\"../codec/Compact\"));\n\nvar _U8a = _interopRequireDefault(require(\"../codec/U8a\")); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name Bytes\n * @description\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\n * as what is found in [[Text]] and [[Vector]])\n */\n\n\nclass Bytes extends _U8a.default {\n  constructor(value) {\n    super(Bytes.decodeBytes(value));\n  }\n\n  static decodeBytes(value) {\n    // FIXME Cyclic dependency, however needed for the StoreageData check below. In a perfect\n    // world, we should probably be checking Bytes - however as a first step, check against\n    // StorageData to cater for the _specific_ problematic case\n    const StorageData = require('./StorageData').default;\n\n    if (Array.isArray(value) || (0, _util.isString)(value)) {\n      const u8a = (0, _util.u8aToU8a)(value);\n      return Bytes.decodeBytes(_Compact.default.addLengthPrefix(u8a));\n    } else if (value instanceof StorageData) {\n      // Here we cater for the actual StorageData that _could_ have a length prefix. In the\n      // case of `:code` it is not added, for others it is\n      const u8a = value;\n\n      const _Compact$default$deco = _Compact.default.decodeU8a(u8a),\n            _Compact$default$deco2 = _slicedToArray(_Compact$default$deco, 2),\n            offset = _Compact$default$deco2[0],\n            length = _Compact$default$deco2[1];\n\n      return u8a.length === length.addn(offset).toNumber() ? u8a.subarray(offset) : u8a;\n    } else if (value instanceof _U8a.default) {\n      // This is required. In the case of a U8a we already have gotten rid of the length,\n      // i.e. new Bytes(new Bytes(...)) will work as expected\n      return value;\n    } else if ((0, _util.isU8a)(value)) {\n      if (!value.length) {\n        return new Uint8Array();\n      } // handle all other Uint8Array inputs, these do have a length prefix\n\n\n      const _Compact$default$deco3 = _Compact.default.decodeU8a(value),\n            _Compact$default$deco4 = _slicedToArray(_Compact$default$deco3, 2),\n            offset = _Compact$default$deco4[0],\n            length = _Compact$default$deco4[1];\n\n      const total = offset + length.toNumber();\n      (0, _util.assert)(total <= value.length, \"Bytes: required length less than remainder, expected at least \".concat(total, \", found \").concat(value.length));\n      return value.subarray(offset, total);\n    }\n\n    return value;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.length + _Compact.default.encodeU8a(this.length).length;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Bytes';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return isBare ? super.toU8a(isBare) : _Compact.default.addLengthPrefix(this);\n  }\n\n}\n\nexports.default = Bytes;","map":null,"metadata":{},"sourceType":"script"}