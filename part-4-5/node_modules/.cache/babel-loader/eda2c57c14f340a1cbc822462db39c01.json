{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = fromMetadata;\n\nvar _types = require(\"@polkadot/types\");\n\nvar _util = require(\"@polkadot/util\"); // Copyright 2017-2019 @polkadot/api-metadata authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * Retrieve the parameter types (module constants) from the runtime metadata.\n *\n * @param metadata - The metadata\n */\n\n\nfunction fromMetadata(metadata) {\n  return metadata.asV7.modules.reduce((result, moduleMetadata) => {\n    if (moduleMetadata.constants.isEmpty) {\n      return result;\n    }\n\n    const name = moduleMetadata.name; // For access, we change the index names, i.e. Democracy.EnactmentPeriod -> democracy.enactmentPeriod\n\n    result[(0, _util.stringCamelCase)(name.toString())] = moduleMetadata.constants.reduce((newModule, meta) => {\n      const codec = (0, _types.createType)(meta.type, meta.value); // This is not a perfect idea, however as it stands with number-only constants on the metadata\n      // does not have any effect. However, this could become problematic in cases where items are\n      // exposed that contain their own metadata. As of now, the compatibility with current, e.g.\n      // storage is the driving factor, one consistent way of handling interfaces\n\n      codec.meta = meta;\n      newModule[(0, _util.stringCamelCase)(meta.name.toString())] = codec;\n      return newModule;\n    }, {});\n    return result;\n  }, {});\n}","map":null,"metadata":{},"sourceType":"script"}