{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Text = _interopRequireDefault(require(\"./Text\")); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nconst ALLOWED_BOXES = ['Compact', 'Option', 'Vec'];\n/**\n * @name Type\n * @description\n * This is a extended version of String, specifically to handle types. Here we rely fully\n * on what string provides us, however we also adjust the types received from the runtime,\n * i.e. we remove the `T::` prefixes found in some types for consistency accross implementation.\n */\n\nclass Type extends _Text.default {\n  constructor() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ''; // First decode it with Text\n\n    const textValue = new _Text.default(value); // Then cleanup the textValue to get the @polkadot/types type, and pass the\n    // sanitized value to constructor\n\n    super(Type.decodeType(textValue.toString()));\n    this._originalLength = void 0;\n    this._originalLength = textValue.encodedLength;\n  }\n\n  static decodeType(value) {\n    const mappings = [// alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\n    Type._alias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport'), // alias TreasuryProposal from Proposal<T::AccountId, BalanceOf<T>>\n    Type._alias('Proposal<T::AccountId, BalanceOf<T>>', 'TreasuryProposal'), // <T::Balance as HasCompact>\n    Type._cleanupCompact(), // Remove all the trait prefixes\n    Type._removeTraits(), // remove PairOf<T> -> (T, T)\n    Type._removePairOf(), // remove boxing, `Box<Proposal>` -> `Proposal`\n    Type._removeWrap('Box'), // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\n    Type._removeGenerics(), // alias String -> Text (compat with jsonrpc methods)\n    Type._alias('String', 'Text'), // alias () -> Null\n    Type._alias('\\\\(\\\\)', 'Null'), // alias Vec<u8> -> Bytes\n    Type._alias('Compact<Index>', 'IndexCompact'), // alias Vec<u8> -> Bytes\n    Type._alias('Vec<u8>', 'Bytes'), // alias &[u8] -> Bytes\n    Type._alias('&\\\\[u8\\\\]', 'Bytes'), // alias RawAddress -> Address\n    Type._alias('RawAddress', 'Address'), // alias Lookup::Source to Address (_could_ be AccountId on certain chains)\n    Type._alias('Lookup::Source', 'Address'), // alias Lookup::Target to AccountId (always the case)\n    Type._alias('Lookup::Target', 'AccountId'), // alias for grandpa, as used in polkadot\n    Type._alias('grandpa::AuthorityId', 'AuthorityId'), // specific for SessionIndex (cvould make this session::, but be conservative)\n    Type._alias('session::SessionIndex', 'SessionIndex'), // HACK duplication between contracts & primitives, however contracts prefixed with exec\n    Type._alias('exec::StorageKey', 'ContractStorageKey'), // flattens tuples with one value, `(AccountId)` -> `AccountId`\n    Type._flattenSingleTuple(), // converts ::Type to Type, <T as Trait<I>>::Proposal -> ::Proposal\n    Type._removeColonPrefix()];\n    return mappings.reduce((result, fn) => {\n      return fn(result);\n    }, value).trim();\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    // NOTE Length is used in the decoding calculations, so return the original (pre-cleanup)\n    // length of the data. Since toU8a is disabled, this does not affect encoding, but rather\n    // only the decoding leg, allowing the decoders to work with original pointers\n    return this._originalLength;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    // Note Since we are mangling what we get in beyond recognition, we really should\n    // not allow the re-encoding. Additionally, this is probably more of a decoder-only\n    // helper, so treat it as such.\n    throw new Error('Type::toU8a: unimplemented');\n  } // given a starting index, find the closing >\n\n\n  static _findClosing(value, start) {\n    let depth = 0;\n\n    for (let index = start; index < value.length; index++) {\n      if (value[index] === '>') {\n        if (!depth) {\n          return index;\n        }\n\n        depth--;\n      } else if (value[index] === '<') {\n        depth++;\n      }\n    }\n\n    throw new Error(\"Unable to find closing matching <> on '\".concat(value, \"' (start \").concat(start, \")\"));\n  }\n\n  static _alias(src, dest) {\n    return value => {\n      return value.replace(new RegExp(src, 'g'), dest);\n    };\n  }\n\n  static _cleanupCompact() {\n    return value => {\n      for (let index = 0; index < value.length; index++) {\n        if (value[index] !== '<') {\n          continue;\n        }\n\n        const end = Type._findClosing(value, index + 1) - 14;\n\n        if (value.substr(end, 14) === ' as HasCompact') {\n          value = \"Compact<\".concat(value.substr(index + 1, end - index - 1), \">\");\n        }\n      }\n\n      return value;\n    };\n  }\n\n  static _flattenSingleTuple() {\n    return value => {\n      return value.replace(/\\(([^,]*)\\)/, '$1');\n    };\n  }\n\n  static _removeColonPrefix() {\n    return value => {\n      return value.replace(/^::/, '');\n    };\n  }\n\n  static _removeGenerics() {\n    return value => {\n      for (let index = 0; index < value.length; index++) {\n        if (value[index] === '<') {\n          // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n          const box = ALLOWED_BOXES.find(box => {\n            const start = index - box.length;\n            return start >= 0 && value.substr(start, box.length) === box;\n          }); // we have not found anything, unwrap generic innards\n\n          if (!box) {\n            const end = Type._findClosing(value, index + 1);\n\n            value = \"\".concat(value.substr(0, index)).concat(value.substr(end + 1));\n          }\n        }\n      }\n\n      return value;\n    };\n  } // remove the PairOf wrappers\n\n\n  static _removePairOf() {\n    return value => {\n      for (let index = 0; index < value.length; index++) {\n        if (value.substr(index, 7) === 'PairOf<') {\n          const start = index + 7;\n\n          const end = Type._findClosing(value, start);\n\n          const type = value.substr(start, end - start);\n          value = \"\".concat(value.substr(0, index), \"(\").concat(type, \",\").concat(type, \")\").concat(value.substr(end + 1));\n        }\n      }\n\n      return value;\n    };\n  } // remove the type traits\n\n\n  static _removeTraits() {\n    return value => {\n      return value // remove all whitespaces\n      .replace(/\\s/g, '') // anything `T::<type>` to end up as `<type>`\n      .replace(/T::/g, '') // anything `Self::<type>` to end up as `<type>`\n      .replace(/Self::/g, '') // `system::` with `` - basically we find `<T as system::Trait>`\n      .replace(/system::/g, '') // replace `<T as Trait>::` (whitespaces were removed above)\n      .replace(/<TasTrait>::/g, '') // replace `<T as something::Trait>::` (whitespaces were removed above)\n      .replace(/<Tas[a-z]+::Trait>::/g, '') // replace `<Self as Trait>::` (whitespaces were removed above)\n      .replace(/<SelfasTrait>::/g, '') // replace <Lookup as StaticLookup>\n      .replace(/<LookupasStaticLookup>/g, 'Lookup') // replace `<...>::Type`\n      .replace(/::Type/g, '') // replace `wasm::*` eg. `wasm::PrefabWasmModule`\n      .replace(/wasm::/g, '');\n    };\n  } // remove wrapping values, i.e. Box<Proposal> -> Proposal\n\n\n  static _removeWrap(_check) {\n    const check = \"\".concat(_check, \"<\");\n    return value => {\n      let index = 0;\n\n      while (index !== -1) {\n        index = value.indexOf(check);\n\n        if (index !== -1) {\n          const start = index + check.length;\n\n          const end = Type._findClosing(value, start);\n\n          value = \"\".concat(value.substr(0, index)).concat(value.substr(start, end - start)).concat(value.substr(end + 1));\n        }\n      }\n\n      return value;\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Type';\n  }\n\n}\n\nexports.default = Type;","map":null,"metadata":{},"sourceType":"script"}