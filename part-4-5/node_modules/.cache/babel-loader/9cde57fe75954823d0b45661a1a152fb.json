{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.MortalEra = exports.ImmortalEra = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Enum = _interopRequireDefault(require(\"../../codec/Enum\"));\n\nvar _Tuple = _interopRequireDefault(require(\"../../codec/Tuple\"));\n\nvar _U8a = _interopRequireDefault(require(\"../../codec/U8a\"));\n\nvar _U = _interopRequireDefault(require(\"../U64\"));\n\nvar _constants = require(\"./constants\"); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nclass ImmortalEra extends _U8a.default {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(value) {\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    super(_constants.IMMORTAL_ERA);\n  }\n\n}\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\n\nexports.ImmortalEra = ImmortalEra;\n\nclass MortalEra extends _Tuple.default {\n  constructor(value) {\n    super({\n      period: _U.default,\n      phase: _U.default\n    }, MortalEra.decodeMortalEra(value));\n  }\n\n  static decodeMortalEra(value) {\n    if ((0, _util.isHex)(value)) {\n      return MortalEra.decodeMortalEra((0, _util.hexToU8a)(value));\n    } else if (Array.isArray(value)) {\n      return MortalEra.decodeMortalEra(new Uint8Array(value));\n    } else if ((0, _util.isU8a)(value)) {\n      if (value.length === 0) {\n        return [new _U.default(), new _U.default()];\n      }\n\n      const first = (0, _util.u8aToBn)(value.subarray(0, 1)).toNumber();\n      const second = (0, _util.u8aToBn)(value.subarray(1, 2)).toNumber();\n      const encoded = first + (second << 8);\n      const period = 2 << encoded % (1 << 4);\n      const quantizeFactor = Math.max(period >> 12, 1);\n      const phase = (encoded >> 4) * quantizeFactor;\n      (0, _util.assert)(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n      return [new _U.default(period), new _U.default(phase)];\n    } else if ((0, _util.isObject)(value)) {\n      const current = value.current,\n            period = value.period;\n      let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n      calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n      const phase = current % calPeriod;\n      const quantizeFactor = Math.max(calPeriod >> 12, 1);\n      const quantizedPhase = phase / quantizeFactor * quantizeFactor;\n      return [new _U.default(calPeriod), new _U.default(quantizedPhase)];\n    } else if (!value) {\n      return [new _U.default(), new _U.default()];\n    }\n\n    throw new Error('Invalid data passed to Mortal era');\n  }\n  /**\n   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n   */\n\n\n  get encodedLength() {\n    return 2;\n  }\n  /**\n   * @description The period of this Mortal wraps as a [[U64]]\n   */\n\n\n  get period() {\n    return this[0];\n  }\n  /**\n   * @description The phase of this Mortal wraps as a [[U64]]\n   */\n\n\n  get phase() {\n    return this[1];\n  }\n  /**\n   * @description Returns a JSON representation of the actual value\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   * Period and phase are encoded:\n   *   - The period of validity from the block hash found in the signing material.\n   *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n   *     implies which block hash is included in the signature material). If the `period` is\n   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n   *     `period` is.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    const period = this.period.toNumber();\n    const phase = this.phase.toNumber();\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const trailingZeros = this.getTrailingZeros(period);\n    const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n    const first = encoded >> 8;\n    const second = encoded & 0xff;\n    return new Uint8Array([second, first]);\n  }\n  /**\n   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n   */\n\n\n  birth(current) {\n    // FIXME No toNumber() here\n    return Math.floor((Math.max((0, _util.bnToBn)(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n  }\n  /**\n   * @description Get the block number of the first block at which the era has ended.\n   */\n\n\n  death(current) {\n    // FIXME No toNumber() here\n    return this.birth(current) + this.period.toNumber();\n  }\n  /**\n   * @description convert the number to binary and get the trailing zero's.\n   */\n\n\n  getTrailingZeros(period) {\n    const binary = period.toString(2);\n    let index = 0;\n\n    while (binary[binary.length - 1 - index] === '0') {\n      index++;\n    }\n\n    return index;\n  }\n\n}\n/**\n * @name ExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\n\nexports.MortalEra = MortalEra;\n\nclass ExtrinsicEra extends _Enum.default {\n  constructor(value) {\n    super({\n      ImmortalEra,\n      MortalEra\n    }, ExtrinsicEra.decodeExtrinsicEra(value));\n  } // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  static decodeExtrinsicEra() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n\n    if (!value) {\n      return new Uint8Array([0]);\n    } else if (value instanceof ExtrinsicEra) {\n      return ExtrinsicEra.decodeExtrinsicEra(value.toU8a());\n    } else if ((0, _util.isHex)(value)) {\n      return ExtrinsicEra.decodeExtrinsicEra((0, _util.hexToU8a)(value));\n    } else if ((0, _util.isU8a)(value)) {\n      if (!value.length || value[0] === 0) {\n        return new Uint8Array([0]);\n      } else {\n        return new Uint8Array([1, value[0], value[1]]);\n      }\n    } else if ((0, _util.isObject)(value)) {\n      // this is to de-serialize from JSON\n      if (value.MortalEra) {\n        return {\n          MortalEra: value.MortalEra\n        };\n      } else if (value.ImmortalEra) {\n        return {\n          ImmortalEra: value.ImmortalEra\n        };\n      }\n\n      return {\n        MortalEra: value\n      };\n    }\n\n    throw new Error('Invalid data passed to Era');\n  }\n  /**\n   * @description Overide the encoded length method\n   */\n\n\n  get encodedLength() {\n    if (this.index === 0) {\n      return this.asImmortalEra.encodedLength;\n    } else {\n      return this.asMortalEra.encodedLength;\n    }\n  }\n  /**\n   * @description Returns the item as a [[ImmortalEra]]\n   */\n\n\n  get asImmortalEra() {\n    (0, _util.assert)(this.isImmortalEra, \"Cannot convert '\".concat(this.type, \"' via asImmortalEra\"));\n    return this.value;\n  }\n  /**\n   * @description Returns the item as a [[MortalEra]]\n   */\n\n\n  get asMortalEra() {\n    (0, _util.assert)(this.isMortalEra, \"Cannot convert '\".concat(this.type, \"' via asMortalEra\"));\n    return this.value;\n  }\n  /**\n   * @description `true` if Immortal\n   */\n\n\n  get isImmortalEra() {\n    return this.index === 0;\n  }\n  /**\n   * @description `true` if Mortal\n   */\n\n\n  get isMortalEra() {\n    return this.index > 0;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n  }\n\n}\n\nexports.default = ExtrinsicEra;","map":null,"metadata":{},"sourceType":"script"}