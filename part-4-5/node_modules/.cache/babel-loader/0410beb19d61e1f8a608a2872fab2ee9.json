{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Keyring = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _pair = _interopRequireDefault(require(\"@polkadot/keyring/pair\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _development = _interopRequireDefault(require(\"./observable/development\"));\n\nvar _Base = _interopRequireDefault(require(\"./Base\"));\n\nvar _defaults = require(\"./defaults\");\n\nvar _options = _interopRequireDefault(require(\"./options\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst RECENT_EXPIRY = 24 * 60 * 60; // No accounts (or test accounts) should be loaded until after the chain determination.\n// Chain determination occurs outside of Keyring. Loading `keyring.loadAll({ type: 'ed25519' | 'sr25519' })` is triggered\n// from the API after the chain is received\n\nclass Keyring extends _Base.default {\n  constructor() {\n    super(...arguments);\n    this.stores = {\n      address: () => this.addresses,\n      contract: () => this.contracts,\n      account: () => this.accounts\n    };\n  }\n\n  addExternal(publicKey) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const pair = this.keyring.addFromAddress(publicKey, _objectSpread({}, meta, {\n      isExternal: true\n    }), null);\n    const json = this.saveAccount(pair);\n    return {\n      json,\n      pair\n    };\n  }\n\n  addPair(pair, password) {\n    this.keyring.addPair(pair);\n    const json = this.saveAccount(pair, password);\n    return {\n      json,\n      pair\n    };\n  }\n\n  addUri(suri, password) {\n    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let type = arguments.length > 3 ? arguments[3] : undefined;\n    const pair = this.keyring.addFromUri(suri, meta, type);\n    const json = this.saveAccount(pair, password);\n    return {\n      json,\n      pair\n    };\n  }\n\n  backupAccount(pair, password) {\n    if (!pair.isLocked) {\n      pair.lock();\n    }\n\n    pair.decodePkcs8(password);\n    return pair.toJson(password);\n  }\n\n  createFromUri(suri) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let type = arguments.length > 2 ? arguments[2] : undefined;\n    return this.keyring.createFromUri(suri, meta, type);\n  }\n\n  encryptAccount(pair, password) {\n    const json = pair.toJson(password);\n    json.meta.whenEdited = Date.now();\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json);\n  }\n\n  forgetAccount(address) {\n    this.keyring.removePair(address);\n    this.accounts.remove(this._store, address);\n  }\n\n  forgetAddress(address) {\n    this.addresses.remove(this._store, address);\n  }\n\n  forgetContract(address) {\n    this.contracts.remove(this._store, address);\n  }\n\n  getAccount(address) {\n    return this.getAddress(address, 'account');\n  }\n\n  getAccounts() {\n    const available = this.accounts.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address, 'account')).filter(account => _development.default.isDevelopment() || account.meta.isTesting !== true);\n  }\n\n  getAddress(_address) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const address = (0, _util.isString)(_address) ? _address : this.encodeAddress(_address);\n    const publicKey = this.decodeAddress(address);\n    const stores = type ? [this.stores[type]] : Object.values(this.stores);\n    const info = stores.reduce((lastInfo, store) => store().subject.getValue()[address] || lastInfo, undefined);\n    return info && {\n      address,\n      publicKey,\n      meta: info.json.meta\n    };\n  }\n\n  getAddresses() {\n    const available = this.addresses.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address));\n  }\n\n  getContract(address) {\n    return this.getAddress(address, 'contract');\n  }\n\n  getContracts() {\n    const available = this.contracts.subject.getValue();\n    return Object.entries(available).filter(_ref => {\n      let _ref4 = _slicedToArray(_ref, 2),\n          data = _ref4[1];\n\n      const contract = data.json.meta.contract;\n      return !!contract && contract.genesisHash === this.genesisHash;\n    }).map(_ref2 => {\n      let _ref5 = _slicedToArray(_ref2, 1),\n          address = _ref5[0];\n\n      return this.getContract(address);\n    });\n  }\n\n  rewriteKey(json, key, hexAddr, creator) {\n    if (hexAddr.substr(0, 2) === '0x') {\n      return;\n    }\n\n    this._store.remove(key);\n\n    this._store.set(creator(hexAddr), json);\n  }\n\n  loadAccount(json, key) {\n    if (!json.meta.isTesting && json.encoded) {\n      // FIXME Just for the transition period (ignoreChecksum)\n      const pair = this.keyring.addFromJson(json, true);\n      this.accounts.add(this._store, pair.address, json);\n    }\n\n    const _key$split = key.split(':'),\n          _key$split2 = _slicedToArray(_key$split, 2),\n          hexAddr = _key$split2[1];\n\n    this.rewriteKey(json, key, hexAddr.trim(), _defaults.accountKey);\n  }\n\n  loadAddress(json, key) {\n    const _json$meta = json.meta,\n          isRecent = _json$meta.isRecent,\n          _json$meta$whenCreate = _json$meta.whenCreated,\n          whenCreated = _json$meta$whenCreate === void 0 ? 0 : _json$meta$whenCreate;\n\n    if (isRecent && Date.now() - whenCreated > RECENT_EXPIRY) {\n      this._store.remove(key);\n\n      return;\n    }\n\n    const address = this.encodeAddress((0, _util.isHex)(json.address) ? (0, _util.hexToU8a)(json.address) // FIXME Just for the transition period (ignoreChecksum)\n    : this.decodeAddress(json.address, true));\n\n    const _key$split3 = key.split(':'),\n          _key$split4 = _slicedToArray(_key$split3, 2),\n          hexAddr = _key$split4[1];\n\n    this.addresses.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, _defaults.addressKey);\n  }\n\n  loadContract(json, key) {\n    const address = this.encodeAddress(this.decodeAddress(json.address));\n\n    const _key$split5 = key.split(':'),\n          _key$split6 = _slicedToArray(_key$split5, 2),\n          hexAddr = _key$split6[1];\n\n    this.contracts.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, _defaults.contractKey);\n  }\n\n  loadInjected(address, meta) {\n    const json = {\n      address,\n      meta: _objectSpread({}, meta, {\n        isInjected: true\n      })\n    };\n    const pair = this.keyring.addFromAddress(address, json.meta);\n    this.accounts.add(this._store, pair.address, json);\n  }\n\n  loadAll(options) {\n    let injected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super.initKeyring(options);\n\n    this._store.all((key, json) => {\n      if (options.filter ? options.filter(json) : true) {\n        if (_defaults.accountRegex.test(key)) {\n          this.loadAccount(json, key);\n        } else if (_defaults.addressRegex.test(key)) {\n          this.loadAddress(json, key);\n        } else if (_defaults.contractRegex.test(key)) {\n          if (json.meta && json.meta.contract && this.genesisHash && this.genesisHash === json.meta.contract.genesisHash) {\n            this.loadContract(json, key);\n          }\n        }\n      }\n    });\n\n    injected.forEach(_ref3 => {\n      let address = _ref3.address,\n          meta = _ref3.meta;\n      return this.loadInjected(address, meta);\n    });\n\n    _options.default.init(this);\n  }\n\n  restoreAccount(json, password) {\n    const type = Array.isArray(json.encoding.content) ? json.encoding.content[1] : 'ed25519';\n    const pair = (0, _pair.default)(type, {\n      // FIXME Just for the transition period (ignoreChecksum)\n      publicKey: this.decodeAddress(json.address, true)\n    }, json.meta, (0, _util.hexToU8a)(json.encoded)); // unlock, save account and then lock (locking cleans secretKey, so needs to be last)\n\n    pair.decodePkcs8(password);\n    this.addPair(pair, password);\n    pair.lock();\n    return pair;\n  }\n\n  saveAccount(pair, password) {\n    this.addTimestamp(pair);\n    const json = pair.toJson(password);\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json);\n    return json;\n  }\n\n  saveAccountMeta(pair, meta) {\n    const address = pair.address;\n\n    this._store.get((0, _defaults.accountKey)(address), json => {\n      pair.setMeta(meta);\n      json.meta = pair.meta;\n      this.accounts.add(this._store, address, json);\n    });\n  }\n\n  saveAddress(address, meta) {\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'address';\n    const available = this.addresses.subject.getValue();\n    const json = available[address] && available[address].json || {\n      address,\n      meta: {\n        isRecent: void 0,\n        whenCreated: Date.now()\n      }\n    };\n    Object.keys(meta).forEach(key => {\n      json.meta[key] = meta[key];\n    });\n    delete json.meta.isRecent;\n    this.stores[type]().add(this._store, address, json);\n    return json;\n  }\n\n  saveContract(address, meta) {\n    return this.saveAddress(address, meta, 'contract');\n  }\n\n  saveRecent(address) {\n    const available = this.addresses.subject.getValue();\n\n    if (!available[address]) {\n      const json = {\n        address,\n        meta: {\n          isRecent: true,\n          whenCreated: Date.now()\n        }\n      };\n      this.addresses.add(this._store, address, json);\n    }\n\n    return this.addresses.subject.getValue()[address];\n  }\n\n}\n\nexports.Keyring = Keyring;\nconst keyringInstance = new Keyring();\nvar _default = keyringInstance;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}