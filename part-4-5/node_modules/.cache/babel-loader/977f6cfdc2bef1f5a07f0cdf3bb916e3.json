{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Base = _interopRequireDefault(require(\"../../codec/Base\"));\n\nvar _Compact = _interopRequireDefault(require(\"../../codec/Compact\"));\n\nvar _Method = _interopRequireDefault(require(\"../Method\"));\n\nvar _Hash = _interopRequireDefault(require(\"../Hash\"));\n\nvar _Extrinsic = _interopRequireDefault(require(\"./v1/Extrinsic\"));\n\nvar _Extrinsic2 = _interopRequireDefault(require(\"./v2/Extrinsic\"));\n\nvar _constants = require(\"./constants\"); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name Extrinsic\n * @description\n * Representation of an Extrinsic in the system. It contains the actual call,\n * (optional) signature and encodes with an actual length prefix\n *\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n *\n * Can be:\n * - signed, to create a transaction\n * - left as is, to create an inherent\n */\n\n\nclass Extrinsic extends _Base.default {\n  constructor(value) {\n    let _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        version = _ref.version;\n\n    super(Extrinsic.decodeExtrinsic(value, version));\n  }\n\n  static newFromValue(value, version) {\n    if (value instanceof Extrinsic) {\n      return value.raw;\n    }\n\n    const isSigned = (version & _constants.BIT_SIGNED) === _constants.BIT_SIGNED;\n    const type = version & _constants.UNMASK_VERSION;\n\n    switch (type) {\n      case 1:\n        return new _Extrinsic.default(value, {\n          isSigned\n        });\n\n      case 2:\n        return new _Extrinsic2.default(value, {\n          isSigned\n        });\n\n      default:\n        throw new Error(\"Unsupported extrinsic version \".concat(type));\n    }\n  }\n\n  static decodeExtrinsic(value) {\n    let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.DEFAULT_VERSION;\n\n    if (Array.isArray(value) || (0, _util.isHex)(value)) {\n      // Instead of the block below, it should simply be:\n      // return Extrinsic.decodeExtrinsic(hexToU8a(value as string));\n      const u8a = (0, _util.u8aToU8a)(value); // HACK 11 Jan 2019 - before https://github.com/paritytech/substrate/pull/1388\n      // extrinsics didn't have the length, cater for both approaches\n\n      const _Compact$default$deco = _Compact.default.decodeU8a(u8a),\n            _Compact$default$deco2 = _slicedToArray(_Compact$default$deco, 2),\n            offset = _Compact$default$deco2[0],\n            length = _Compact$default$deco2[1];\n\n      const withPrefix = u8a.length === offset + length.toNumber();\n      return Extrinsic.decodeExtrinsic(withPrefix ? u8a : _Compact.default.addLengthPrefix(u8a), version);\n    } else if ((0, _util.isU8a)(value)) {\n      if (!value.length) {\n        return Extrinsic.newFromValue(new Uint8Array(), version);\n      }\n\n      const _Compact$default$deco3 = _Compact.default.decodeU8a(value),\n            _Compact$default$deco4 = _slicedToArray(_Compact$default$deco3, 2),\n            offset = _Compact$default$deco4[0],\n            length = _Compact$default$deco4[1];\n\n      const total = offset + length.toNumber();\n      (0, _util.assert)(total <= value.length, \"Extrinsic: required length less than remainder, expected at least \".concat(total, \", found \").concat(value.length));\n      return Extrinsic.decodeU8a(value.subarray(offset, total));\n    } else if (value instanceof _Method.default) {\n      return Extrinsic.newFromValue({\n        method: value\n      }, version);\n    }\n\n    return Extrinsic.newFromValue(value, version);\n  }\n\n  static decodeU8a(value) {\n    return Extrinsic.newFromValue(value.subarray(1), value[0]);\n  }\n  /**\n   * @description The arguments passed to for the call, exposes args so it is compatible with [[Method]]\n   */\n\n\n  get args() {\n    return this.method.args;\n  }\n  /**\n   * @description Thge argument defintions, compatible with [[Method]]\n   */\n\n\n  get argsDef() {\n    return this.method.argsDef;\n  }\n  /**\n   * @description The actual `[sectionIndex, methodIndex]` as used in the Method\n   */\n\n\n  get callIndex() {\n    return this.method.callIndex;\n  }\n  /**\n   * @description The actual data for the Method\n   */\n\n\n  get data() {\n    return this.method.data;\n  }\n  /**\n   * @description The era for thios extrinsic\n   */\n\n\n  get era() {\n    return this.raw.signature.era;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.toU8a().length;\n  }\n  /**\n   * @description Convernience function, encodes the extrinsic and returns the actual hash\n   */\n\n\n  get hash() {\n    return new _Hash.default((0, _utilCrypto.blake2AsU8a)(this.toU8a(), 256));\n  }\n  /**\n   * @description `true` is method has `Origin` argument (compatibility with [[Method]])\n   */\n\n\n  get hasOrigin() {\n    return this.method.hasOrigin;\n  }\n  /**\n   * @description `true` id the extrinsic is signed\n   */\n\n\n  get isSigned() {\n    return this.raw.signature.isSigned;\n  }\n  /**\n   * @description The length of the actual data, excluding prefix\n   */\n\n\n  get length() {\n    return this.toU8a(true).length;\n  }\n  /**\n   * @description The [[FunctionMetadata]] that describes the extrinsic\n   */\n\n\n  get meta() {\n    return this.method.meta;\n  }\n  /**\n   * @description The [[Method]] this extrinsic wraps\n   */\n\n\n  get method() {\n    return this.raw.method;\n  }\n  /**\n   * @description The nonce for this extrinsic\n   */\n\n\n  get nonce() {\n    return this.raw.signature.nonce;\n  }\n  /**\n   * @description The [[ExtrinsicSignature]]\n   */\n\n\n  get signature() {\n    return this.raw.signature.signature;\n  }\n  /**\n   * @description The [[Address]] that signed\n   */\n\n\n  get signer() {\n    return this.raw.signature.signer;\n  }\n  /**\n   * @description Forwards compat\n   */\n\n\n  get tip() {\n    return this.raw.signature.tip;\n  }\n  /**\n   * @description Returns the raw transaction version (not flagged with signing information)\n  */\n\n\n  get type() {\n    return this.raw.version;\n  }\n  /**\n   * @description Returns the encoded version flag\n  */\n\n\n  get version() {\n    return this.type | (this.isSigned ? _constants.BIT_SIGNED : _constants.BIT_UNSIGNED);\n  }\n  /**\n   * @description Add an [[ExtrinsicSignature]] to the extrinsic (already generated)\n   */\n\n\n  addSignature(signer, signature) {\n    // FIXME Support for current extensions where 2 values are being passed in here, i.e.\n    //   addSignature(signer, signature, nonce, era);\n    // The above signature should be changed to the correct format in the next cycle, i.e.\n    //   payload: ExtrinsicPayloadValue | Uint8Array | string\n    let payload = arguments.length <= 2 ? undefined : arguments[2]; // @ts-ignore\n\n    if ((arguments.length <= 2 ? 0 : arguments.length - 2) === 2) {\n      payload = {\n        // @ts-ignore\n        era: arguments.length <= 3 ? undefined : arguments[3],\n        method: this.method.toHex(),\n        nonce: arguments.length <= 2 ? undefined : arguments[2],\n        tip: 0\n      };\n    }\n\n    this.raw.addSignature(signer, signature, payload);\n    return this;\n  }\n  /**\n   * @description Sign the extrinsic with a specific keypair\n   */\n\n\n  sign(account, options) {\n    this.raw.sign(account, options);\n    return this;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return (0, _util.u8aToHex)(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Extrinsic';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = (0, _util.u8aConcat)(new Uint8Array([this.version]), this.raw.toU8a(isBare));\n    return isBare ? encoded : _Compact.default.addLengthPrefix(encoded);\n  }\n\n}\n\nexports.default = Extrinsic;","map":null,"metadata":{},"sourceType":"script"}