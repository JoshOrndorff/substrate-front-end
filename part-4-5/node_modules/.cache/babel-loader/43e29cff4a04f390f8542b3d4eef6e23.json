{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.web3Enable = web3Enable;\nexports.web3Accounts = web3Accounts;\nexports.web3AccountsSubscribe = web3AccountsSubscribe;\nexports.web3FromSource = web3FromSource;\nexports.web3FromAddress = web3FromAddress;\nexports.web3EnablePromise = exports.isWeb3Injected = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _compat = _interopRequireDefault(require(\"./compat\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // just a helper (otherwise we cast all-over, so shorter and more readable)\n\n\nconst win = window; // don't clobber the existing object, but ensure non-undefined\n\nwin.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available\n\nfunction web3IsInjected() {\n  return Object.keys(win.injectedWeb3).length !== 0;\n} // helper to throw a consistent error when not enabled\n\n\nfunction throwError(method) {\n  throw new Error(\"\".concat(method, \": web3Enable(originName) needs to be called before \").concat(method));\n} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>\n\n\nfunction mapAccounts(source, list) {\n  return list.map(_ref => {\n    let address = _ref.address,\n        name = _ref.name;\n    return {\n      address,\n      meta: {\n        name,\n        source\n      }\n    };\n  });\n} // have we found a properly constructed window.injectedWeb3\n\n\nlet isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)\n\nexports.isWeb3Injected = isWeb3Injected;\nlet web3EnablePromise = null;\nexports.web3EnablePromise = web3EnablePromise; // enables all the providers found on the injected window interface\n\nfunction web3Enable(originName) {\n  exports.web3EnablePromise = web3EnablePromise = (0, _compat.default)().then(() => Promise.all(Object.entries(win.injectedWeb3).map(_ref2 => {\n    let _ref11 = _slicedToArray(_ref2, 2),\n        name = _ref11[0],\n        _ref11$ = _ref11[1],\n        enable = _ref11$.enable,\n        version = _ref11$.version;\n\n    return Promise.all([Promise.resolve({\n      name,\n      version\n    }), enable(originName).catch(error => {\n      console.error(\"Error initializing \".concat(name, \": \").concat(error.message));\n    })]);\n  })).then(values => values.filter(_ref3 => {\n    let _ref12 = _slicedToArray(_ref3, 2),\n        ext = _ref12[1];\n\n    return !!ext;\n  }).map(_ref4 => {\n    let _ref13 = _slicedToArray(_ref4, 2),\n        info = _ref13[0],\n        ext = _ref13[1]; // if we don't have an accounts subscriber, add a single-shot version\n\n\n    if (ext && !ext.accounts.subscribe) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ext.accounts.subscribe = cb => {\n        ext.accounts.get().then(cb).catch(console.error);\n        return () => {// no ubsubscribe needed, this is a single-shot\n        };\n      };\n    }\n\n    const injected = _objectSpread({}, info, {}, ext);\n\n    return injected;\n  })).catch(() => []).then(values => {\n    const names = values.map(_ref5 => {\n      let name = _ref5.name,\n          version = _ref5.version;\n      return \"\".concat(name, \"/\").concat(version);\n    });\n    exports.isWeb3Injected = isWeb3Injected = web3IsInjected();\n    console.log(\"web3Enable: Enabled \".concat(values.length, \" extension\").concat(values.length !== 1 ? 's' : '', \": \").concat(names.join(', ')));\n    return values;\n  }));\n  return web3EnablePromise;\n} // retrieve all the accounts accross all providers\n\n\nasync function web3Accounts() {\n  if (!web3EnablePromise) {\n    return throwError('web3Accounts');\n  }\n\n  const accounts = [];\n  const injected = await web3EnablePromise;\n  const retrieved = await Promise.all(injected.map(async _ref6 => {\n    let accounts = _ref6.accounts,\n        source = _ref6.name;\n\n    try {\n      const list = await accounts.get();\n      return mapAccounts(source, list);\n    } catch (error) {\n      // cannot handle this one\n      return [];\n    }\n  }));\n  retrieved.forEach(result => {\n    accounts.push(...result);\n  });\n  const addresses = accounts.map(_ref7 => {\n    let address = _ref7.address;\n    return address;\n  });\n  console.log(\"web3Accounts: Found \".concat(accounts.length, \" address\").concat(accounts.length !== 1 ? 'es' : '', \": \").concat(addresses.join(', ')));\n  return accounts;\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nasync function web3AccountsSubscribe(cb) {\n  if (!web3EnablePromise) {\n    return throwError('web3AccountsSubscribe');\n  }\n\n  const accounts = {};\n\n  const triggerUpdate = () => {\n    cb(Object.entries(accounts).reduce((result, _ref8) => {\n      let _ref14 = _slicedToArray(_ref8, 2),\n          source = _ref14[0],\n          list = _ref14[1];\n\n      result.push(...mapAccounts(source, list));\n      return result;\n    }, []));\n  };\n\n  const unsubs = (await web3EnablePromise).map(_ref9 => {\n    let subscribe = _ref9.accounts.subscribe,\n        source = _ref9.name;\n    return subscribe(result => {\n      accounts[source] = result;\n      triggerUpdate();\n    });\n  });\n  return () => {\n    unsubs.forEach(unsub => {\n      unsub();\n    });\n  };\n} // find a specific provider based on the name\n\n\nasync function web3FromSource(source) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromSource');\n  }\n\n  const sources = await web3EnablePromise;\n  const found = source && sources.find(_ref10 => {\n    let name = _ref10.name;\n    return name === source;\n  });\n\n  if (!found) {\n    throw new Error(\"web3FromSource: Unable to find an injected \".concat(source));\n  }\n\n  return found;\n} // find a specific provider based on an address\n\n\nasync function web3FromAddress(address) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromAddress');\n  }\n\n  const accounts = await web3Accounts();\n  const found = address && accounts.find(account => account.address === address);\n\n  if (!found) {\n    throw new Error(\"web3FromAddress: Unable to find injected \".concat(address));\n  }\n\n  return web3FromSource(found.meta.source);\n}","map":null,"metadata":{},"sourceType":"script"}