{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nrequire(\"./polyfill\");\n\nvar _eventemitter = _interopRequireDefault(require(\"eventemitter3\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _coder = _interopRequireDefault(require(\"../coder\"));\n\nvar _defaults = _interopRequireDefault(require(\"../defaults\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst ALIASSES = {\n  chain_finalisedHead: 'chain_finalizedHead',\n  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst l = (0, _util.logger)('api-ws');\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import WsProvider from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\n\nclass WsProvider {\n  /**\n   * @param {string}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`\n   * @param {boolean} autoConnect Whether to connect automatically or not.\n   */\n  constructor() {\n    let endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _defaults.default.WS_URL;\n    let autoConnect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this._eventemitter = void 0;\n    this._isConnected = false;\n    this.autoConnect = void 0;\n    this.coder = void 0;\n    this.endpoint = void 0;\n    this.handlers = void 0;\n    this.queued = void 0;\n    this.subscriptions = void 0;\n    this.waitingForId = void 0;\n    this.websocket = void 0;\n\n    this.onSocketClose = event => {\n      if (this.autoConnect) {\n        l.error(\"disconnected from \".concat(this.endpoint, \" code: '\").concat(event.code, \"' reason: '\").concat(event.reason, \"'\"));\n      }\n\n      this._isConnected = false;\n      this.emit('disconnected');\n\n      if (this.autoConnect) {\n        setTimeout(() => {\n          this.connect();\n        }, 1000);\n      }\n    };\n\n    this.onSocketError = error => {\n      l.debug(() => ['socket error', error]);\n      this.emit('error', error);\n    };\n\n    this.onSocketMessage = message => {\n      l.debug(() => ['received', message.data]);\n      const response = JSON.parse(message.data);\n      return (0, _util.isUndefined)(response.method) ? this.onSocketMessageResult(response) : this.onSocketMessageSubscribe(response);\n    };\n\n    this.onSocketMessageResult = response => {\n      const handler = this.handlers[response.id];\n\n      if (!handler) {\n        l.debug(() => \"Unable to find handler for id=\".concat(response.id));\n        return;\n      }\n\n      try {\n        const method = handler.method,\n              params = handler.params,\n              subscription = handler.subscription;\n        const result = this.coder.decodeResponse(response); // first send the result - in case of subs, we may have an update\n        // immediately if we have some queued results already\n\n        handler.callback(null, result);\n\n        if (subscription) {\n          const subId = \"\".concat(subscription.type, \"::\").concat(result);\n          this.subscriptions[subId] = _objectSpread({}, subscription, {\n            method,\n            params\n          }); // if we have a result waiting for this subscription already\n\n          if (this.waitingForId[subId]) {\n            this.onSocketMessageSubscribe(this.waitingForId[subId]);\n          }\n        }\n      } catch (error) {\n        handler.callback(error, undefined);\n      }\n\n      delete this.handlers[response.id];\n    };\n\n    this.onSocketMessageSubscribe = response => {\n      const method = ALIASSES[response.method] || response.method;\n      const subId = \"\".concat(method, \"::\").concat(response.params.subscription);\n      const handler = this.subscriptions[subId];\n\n      if (!handler) {\n        // store the JSON, we could have out-of-order subid coming in\n        this.waitingForId[subId] = response;\n        l.debug(() => \"Unable to find handler for subscription=\".concat(subId));\n        return;\n      } // housekeeping\n\n\n      delete this.waitingForId[subId];\n\n      try {\n        const result = this.coder.decodeResponse(response);\n        handler.callback(null, result);\n      } catch (error) {\n        handler.callback(error, undefined);\n      }\n    };\n\n    this.onSocketOpen = () => {\n      (0, _util.assert)(!(0, _util.isNull)(this.websocket), 'WebSocket cannot be null in onOpen');\n      l.debug(() => ['connected to', this.endpoint]);\n      this._isConnected = true;\n      this.emit('connected');\n      this.sendQueue();\n      this.resubscribe();\n      return true;\n    };\n\n    (0, _util.assert)(/^(wss|ws):\\/\\//.test(endpoint), \"Endpoint should start with 'ws://', received '\".concat(endpoint, \"'\"));\n    this._eventemitter = new _eventemitter.default();\n    this.autoConnect = autoConnect;\n    this.coder = new _coder.default();\n    this.endpoint = endpoint;\n    this.handlers = {};\n    this.queued = {};\n    this.subscriptions = {};\n    this.waitingForId = {};\n    this.websocket = null;\n\n    if (autoConnect) {\n      this.connect();\n    }\n  }\n  /**\n   * @summary `true` when this provider supports subscriptions\n   */\n\n\n  get hasSubscriptions() {\n    return true;\n  }\n  /**\n   * @description Returns a clone of the object\n   */\n\n\n  clone() {\n    return new WsProvider(this.endpoint);\n  }\n  /**\n   * @summary Manually connect\n   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n   * connect manually using this method.\n   */\n\n\n  connect() {\n    try {\n      this.websocket = new WebSocket(this.endpoint);\n      this.websocket.onclose = this.onSocketClose;\n      this.websocket.onerror = this.onSocketError;\n      this.websocket.onmessage = this.onSocketMessage;\n      this.websocket.onopen = this.onSocketOpen;\n    } catch (error) {\n      l.error(error);\n    }\n  }\n  /**\n   * @description Manually disconnect from the connection, clearing autoconnect logic\n   */\n\n\n  disconnect() {\n    if ((0, _util.isNull)(this.websocket)) {\n      throw new Error('Cannot disconnect on a non-open websocket');\n    } // switch off autoConnect, we are in manual mode now\n\n\n    this.autoConnect = false; // 1000 - Normal closure; the connection successfully completed\n\n    this.websocket.close(1000);\n    this.websocket = null;\n  }\n  /**\n   * @summary Whether the node is connected or not.\n   * @return {boolean} true if connected\n   */\n\n\n  isConnected() {\n    return this._isConnected;\n  }\n  /**\n   * @summary Listens on events after having subscribed using the [[subscribe]] function.\n   * @param  {ProviderInterfaceEmitted} type Event\n   * @param  {ProviderInterfaceEmitCb}  sub  Callback\n   */\n\n\n  on(type, sub) {\n    this._eventemitter.on(type, sub);\n  }\n  /**\n   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n   * @param method The RPC methods to execute\n   * @param params Encoded paramaters as appliucable for the method\n   * @param subscription Subscription details (internally used)\n   */\n\n\n  send(method, params, subscription) {\n    return new Promise((resolve, reject) => {\n      try {\n        const json = this.coder.encodeJson(method, params);\n        const id = this.coder.getId();\n\n        const callback = (error, result) => {\n          error ? reject(error) : resolve(result);\n        };\n\n        l.debug(() => ['calling', method, json]);\n        this.handlers[id] = {\n          callback,\n          method,\n          params,\n          subscription\n        };\n\n        if (this.isConnected() && !(0, _util.isNull)(this.websocket)) {\n          this.websocket.send(json);\n        } else {\n          this.queued[id] = json;\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  /**\n   * @name subscribe\n   * @summary Allows subscribing to a specific event.\n   * @param  {string}                     type     Subscription type\n   * @param  {string}                     method   Subscription method\n   * @param  {any[]}                 params   Parameters\n   * @param  {ProviderInterfaceCallback} callback Callback\n   * @return {Promise<number>}                     Promise resolving to the dd of the subscription you can use with [[unsubscribe]].\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * const provider = new WsProvider('ws://127.0.0.1:9944');\n   * const rpc = new Rpc(provider);\n   *\n   * rpc.state.subscribeStorage([[storage.balances.freeBalance, <Address>]], (_, values) => {\n   *   console.log(values)\n   * }).then((subscriptionId) => {\n   *   console.log('balance changes subscription id: ', subscriptionId)\n   * })\n   * ```\n   */\n\n\n  async subscribe(type, method, params, callback) {\n    const id = await this.send(method, params, {\n      callback,\n      type\n    });\n    return id;\n  }\n  /**\n   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n   */\n\n\n  async unsubscribe(type, method, id) {\n    const subscription = \"\".concat(type, \"::\").concat(id); // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n    // the assigned id now does not match what the API user originally received. It has\n    // a slight complication in solving - since we cannot rely on the send id, but rather\n    // need to find the actual subscription id to map it\n\n    if ((0, _util.isUndefined)(this.subscriptions[subscription])) {\n      l.debug(() => \"Unable to find active subscription=\".concat(subscription));\n      return false;\n    }\n\n    delete this.subscriptions[subscription];\n    const result = await this.send(method, [id]);\n    return result;\n  }\n\n  emit(type) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    this._eventemitter.emit(type, ...args);\n  }\n\n  resubscribe() {\n    const subscriptions = this.subscriptions;\n    this.subscriptions = {};\n    Object.keys(subscriptions).forEach(async id => {\n      const _subscriptions$id = subscriptions[id],\n            callback = _subscriptions$id.callback,\n            method = _subscriptions$id.method,\n            params = _subscriptions$id.params,\n            type = _subscriptions$id.type; // only re-create subscriptions which are not in author (only area where\n      // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n      // are not included (and will not be re-broadcast)\n\n      if (type.startsWith('author_')) {\n        return;\n      }\n\n      try {\n        await this.subscribe(type, method, params, callback);\n      } catch (error) {\n        l.error(error);\n      }\n    });\n  }\n\n  sendQueue() {\n    Object.keys(this.queued).forEach(id => {\n      try {\n        // @ts-ignore we have done the websocket check in onSocketOpen, if an issue, will catch it\n        this.websocket.send(this.queued[id]);\n        delete this.queued[id];\n      } catch (error) {\n        l.error(error);\n      }\n    });\n  }\n\n}\n\nexports.default = WsProvider;","map":null,"metadata":{},"sourceType":"script"}