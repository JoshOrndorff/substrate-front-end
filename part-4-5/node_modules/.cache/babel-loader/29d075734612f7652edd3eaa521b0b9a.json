{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPair;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _toJson2 = _interopRequireDefault(require(\"./toJson\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst isSr25519 = type => type === 'sr25519';\n\nconst fromSeed = (type, seed) => isSr25519(type) ? (0, _utilCrypto.schnorrkelKeypairFromSeed)(seed) : (0, _utilCrypto.naclKeypairFromSeed)(seed);\n\nconst _sign = (type, message, pair) => isSr25519(type) ? (0, _utilCrypto.schnorrkelSign)(message, pair) : (0, _utilCrypto.naclSign)(message, pair);\n\nconst _verify = (type, message, signature, publicKey) => isSr25519(type) ? (0, _utilCrypto.schnorrkelVerify)(message, signature, publicKey) : (0, _utilCrypto.naclVerify)(message, signature, publicKey);\n/**\n * @name pair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\n\nfunction createPair(type, _ref) {\n  let publicKey = _ref.publicKey,\n      secretKey = _ref.secretKey;\n  let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let encoded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return {\n    type,\n\n    get address() {\n      return (0, _utilCrypto.encodeAddress)(publicKey);\n    },\n\n    decodePkcs8: (passphrase, _encoded) => {\n      const decoded = (0, _decode.default)(passphrase, _encoded || encoded);\n\n      if (decoded.secretKey.length === 64) {\n        publicKey = decoded.publicKey;\n        secretKey = decoded.secretKey;\n      } else {\n        const pair = fromSeed(type, decoded.secretKey);\n        publicKey = pair.publicKey;\n        secretKey = pair.secretKey;\n      }\n    },\n    encodePkcs8: passphrase => (0, _encode.default)({\n      publicKey,\n      secretKey\n    }, passphrase),\n\n    get meta() {\n      return meta;\n    },\n\n    get isLocked() {\n      return !secretKey || secretKey.length === 0;\n    },\n\n    lock: () => {\n      secretKey = new Uint8Array(0);\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    setMeta: additional => {\n      meta = _objectSpread({}, meta, {}, additional);\n    },\n    sign: message => _sign(type, message, {\n      publicKey,\n      secretKey\n    }),\n    toJson: passphrase => (0, _toJson2.default)(type, {\n      meta,\n      publicKey\n    }, (0, _encode.default)({\n      publicKey,\n      secretKey\n    }, passphrase), !!passphrase),\n    verify: (message, signature) => _verify(type, message, signature, publicKey)\n  };\n}","map":null,"metadata":{},"sourceType":"script"}