{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createSubmittableExtrinsic;\nexports.SubmittableResult = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _types = require(\"@polkadot/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _filterEvents = _interopRequireDefault(require(\"./util/filterEvents\"));\n\nvar _SignerPayload = _interopRequireDefault(require(\"./SignerPayload\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // The default for 6s allowing for 5min eras. When translating this to faster blocks -\n//   - 4s = (10 / 15) * 5 = 3.33m\n//   - 2s = (10 / 30) * 5 = 1.66m\n\n\nconst BLOCKTIME = 6;\nconst ONE_MINUTE = 60 / BLOCKTIME;\nconst DEFAULT_MORTAL_LENGTH = 5 * ONE_MINUTE;\n\nfunction isKeyringPair(account) {\n  return (0, _util.isFunction)(account.sign);\n}\n\nclass SubmittableResult {\n  constructor(_ref) {\n    let events = _ref.events,\n        status = _ref.status;\n    this.events = void 0;\n    this.status = void 0;\n    this.events = events || [];\n    this.status = status;\n  }\n\n  get isCompleted() {\n    return this.isError || this.isFinalized;\n  }\n\n  get isError() {\n    return this.status.isDropped || this.status.isInvalid || this.status.isUsurped;\n  }\n\n  get isFinalized() {\n    return this.status.isFinalized;\n  }\n  /**\n   * @description Finds an EventRecord for the specified method & section\n   */\n\n\n  findRecord(section, method) {\n    return this.events.find(_ref2 => {\n      let event = _ref2.event;\n      return event.section === section && event.method === method;\n    });\n  }\n\n}\n\nexports.SubmittableResult = SubmittableResult;\n\nfunction createSubmittableExtrinsic(type, api, decorateMethod, extrinsic, trackingCb) {\n  const _extrinsic = new ((0, _types.getTypeRegistry)().getOrThrow('Extrinsic'))(extrinsic, {\n    version: api.extrinsicType\n  });\n\n  const _noStatusCb = type === 'rxjs';\n\n  function updateSigner(updateId, status) {\n    if (updateId !== -1 && api.signer && api.signer.update) {\n      api.signer.update(updateId, status);\n    }\n  }\n\n  function statusObservable(status) {\n    if (!status.isFinalized) {\n      const result = new SubmittableResult({\n        status\n      });\n      trackingCb && trackingCb(result);\n      return (0, _rxjs.of)(result);\n    }\n\n    const blockHash = status.asFinalized;\n    return (0, _rxjs.combineLatest)([api.rpc.chain.getBlock(blockHash), api.query.system.events.at(blockHash)]).pipe((0, _operators.map)(_ref3 => {\n      let _ref6 = _slicedToArray(_ref3, 2),\n          signedBlock = _ref6[0],\n          allEvents = _ref6[1];\n\n      const result = new SubmittableResult({\n        events: (0, _filterEvents.default)(_extrinsic.hash, signedBlock, allEvents),\n        status\n      });\n      trackingCb && trackingCb(result);\n      return result;\n    }));\n  }\n\n  function sendObservable() {\n    let updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    return api.rpc.author.submitExtrinsic(_extrinsic).pipe((0, _operators.tap)(hash => {\n      updateSigner(updateId, hash);\n    }));\n  }\n\n  function subscribeObservable() {\n    let updateId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    return api.rpc.author.submitAndWatchExtrinsic(_extrinsic).pipe((0, _operators.switchMap)(status => statusObservable(status)), (0, _operators.tap)(status => {\n      updateSigner(updateId, status);\n    }));\n  }\n\n  function expandOptions(options, extras) {\n    return _objectSpread({\n      blockHash: api.genesisHash,\n      version: api.runtimeVersion\n    }, options, {}, extras);\n  }\n\n  function expandEraOptions(options, _ref4) {\n    let header = _ref4.header,\n        nonce = _ref4.nonce;\n\n    if (!header) {\n      if ((0, _util.isNumber)(options.era)) {\n        // since we have no header, it is immortal, remove any option overrides\n        // so we only supply the genesisHash and no era to the construction\n        delete options.era;\n        delete options.blockHash;\n      }\n\n      return expandOptions(options, {\n        nonce\n      });\n    }\n\n    const blockNumber = header.blockNumber,\n          hash = header.hash;\n    return expandOptions(options, {\n      blockHash: hash,\n      era: new _types.ExtrinsicEra({\n        current: blockNumber,\n        period: options.era || DEFAULT_MORTAL_LENGTH\n      }),\n      nonce\n    });\n  }\n\n  const signOrigin = _extrinsic.sign;\n  Object.defineProperties(_extrinsic, {\n    send: {\n      value: function value(statusCb) {\n        const isSubscription = _noStatusCb || !!statusCb;\n        return decorateMethod(isSubscription ? subscribeObservable : sendObservable)(statusCb);\n      }\n    },\n    sign: {\n      value: function value(account, optionOrNonce) {\n        // HACK here we actually override nonce if it was specified (backwards compat for\n        // the previous signature - don't let userspace break, but allow then time to upgrade)\n        const options = (0, _util.isBn)(optionOrNonce) || (0, _util.isNumber)(optionOrNonce) ? {\n          nonce: optionOrNonce\n        } : optionOrNonce;\n        signOrigin.apply(_extrinsic, [account, expandOptions(options, {})]);\n        return this;\n      }\n    },\n    signAndSend: {\n      value: function value(account, optionsOrStatus, statusCb) {\n        let options = {};\n\n        if ((0, _util.isFunction)(optionsOrStatus)) {\n          statusCb = optionsOrStatus;\n        } else {\n          options = _objectSpread({}, optionsOrStatus);\n        }\n\n        const isSubscription = _noStatusCb || !!statusCb;\n        const address = isKeyringPair(account) ? account.address : account.toString();\n        let updateId;\n        return decorateMethod(() => (0, _rxjs.combineLatest)([// if we have a nonce already, don't retrieve the latest, use what is there\n        (0, _util.isUndefined)(options.nonce) ? api.query.system.accountNonce(address) : (0, _rxjs.of)(new _types.Index(options.nonce)), // if we have an era provided already or eraLength is <= 0 (immortal)\n        // don't get the latest block, just pass null, handle in mergeMap\n        (0, _util.isUndefined)(options.era) || (0, _util.isNumber)(options.era) && options.era > 0 ? api.rpc.chain.getHeader() : (0, _rxjs.of)(null)]).pipe((0, _operators.first)(), (0, _operators.mergeMap)(async _ref5 => {\n          let _ref7 = _slicedToArray(_ref5, 2),\n              nonce = _ref7[0],\n              header = _ref7[1];\n\n          const eraOptions = expandEraOptions(options, {\n            header,\n            nonce\n          }); // FIXME This is becoming real messy with all the options - way past\n          // \"a method should fit on a single screen\" stage. (Probably want to\n          // clean this when we remove `api.signer.sign` in the next beta cycle)\n\n          if (isKeyringPair(account)) {\n            this.sign(account, eraOptions);\n          } else if (api.signer) {\n            if (api.signer.signPayload) {\n              const signPayload = new _SignerPayload.default(_objectSpread({}, eraOptions, {\n                address,\n                method: _extrinsic.method,\n                blockNumber: header ? header.blockNumber : 0,\n                genesisHash: api.genesisHash,\n                version: api.extrinsicType\n              }));\n              const result = await api.signer.signPayload(signPayload.toPayload()); // Here we explicitly call `toPayload()` again instead of working with an object\n              // (reference) as passed to the signer. This means that we are sure that the\n              // payload data is not modified from our inputs, but the signer\n\n              _extrinsic.addSignature(address, result.signature, signPayload.toPayload());\n\n              updateId = result.id;\n            } else if (api.signer.sign) {\n              console.warn('The Signer.sign interface is deprecated and will be removed in a future version, Swap to using the Signer.signPayload interface instead.');\n              updateId = await api.signer.sign(_extrinsic, address, _objectSpread({}, eraOptions, {\n                blockNumber: header ? header.blockNumber : new _bn.default(0),\n                genesisHash: api.genesisHash\n              }));\n            } else {\n              throw new Error('Invalid signer interface');\n            }\n          } else {\n            throw new Error('no signer exists');\n          }\n        }), (0, _operators.switchMap)(() => {\n          return isSubscription ? subscribeObservable(updateId) : sendObservable(updateId);\n        })))(statusCb);\n      }\n    }\n  });\n  return _extrinsic;\n}","map":null,"metadata":{},"sourceType":"script"}