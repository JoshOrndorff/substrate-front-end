{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utils = require(\"./utils\");\n\nvar _AbstractArray = _interopRequireDefault(require(\"./AbstractArray\")); // Copyright 2017-2019 @polkadot/types authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\n\n\nclass Tuple extends _AbstractArray.default {\n  constructor(Types, value) {\n    super(...Tuple.decodeTuple(Types, value));\n    this._Types = void 0;\n    this._Types = Types;\n  }\n\n  static decodeTuple(_Types, value) {\n    if ((0, _util.isU8a)(value)) {\n      return (0, _utils.decodeU8a)(value, _Types);\n    } else if ((0, _util.isHex)(value)) {\n      return Tuple.decodeTuple(_Types, (0, _util.hexToU8a)(value));\n    }\n\n    const Types = Array.isArray(_Types) ? _Types : Object.values(_Types);\n    return Types.map((Type, index) => {\n      try {\n        return new Type(value && value[index]);\n      } catch (error) {\n        throw new Error(\"Tuple: failed on \".concat(index, \":: \").concat(error.message));\n      }\n    });\n  }\n\n  static with(Types) {\n    return class extends Tuple {\n      constructor(value) {\n        super(Types, value);\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.reduce((length, entry) => {\n      length += entry.encodedLength;\n      return length;\n    }, 0);\n  }\n  /**\n   * @description The types definition of the tuple\n   */\n\n\n  get Types() {\n    return Array.isArray(this._Types) ? this._Types.map(_ref => {\n      let name = _ref.name;\n      return name;\n    }) : Object.keys(this._Types);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    const types = (Array.isArray(this._Types) ? this._Types : Object.values(this._Types)).map(Type => new Type().toRawType());\n    return \"(\".concat(types.join(','), \")\");\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    // Overwrite the default toString representation of Array.\n    return JSON.stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return (0, _util.u8aConcat)(...this.map(entry => entry.toU8a(isBare)));\n  }\n\n}\n\nexports.default = Tuple;","map":null,"metadata":{},"sourceType":"script"}