{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/thib/github/substrate-developer-hub/basic-dapp/part-4-5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.info = info;\n\nvar _bn = _interopRequireDefault(require(\"bn.js\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _types = require(\"@polkadot/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _bestNumber = require(\"../chain/bestNumber\");\n\nvar _eraLength = require(\"../session/eraLength\");\n\nvar _drr = require(\"../util/drr\"); // Copyright 2017-2019 @polkadot/api-derive authors & contributors\n// This software may be modified and distributed under the terms\n// of the Apache-2.0 license. See the LICENSE file for details.\n\n\nfunction groupByEra(list) {\n  return list.reduce((map, _ref) => {\n    let era = _ref.era,\n        value = _ref.value;\n    const key = era.toString();\n\n    if (!map[key]) {\n      map[key] = value;\n    } else {\n      map[key] = map[key].add(value);\n    }\n\n    return map;\n  }, {});\n}\n\nfunction remainingBlocks(era, eraLength, bestNumber) {\n  const remaining = eraLength.mul(era).sub(bestNumber);\n  return remaining.lten(0) ? new _bn.default(0) : remaining;\n}\n\nfunction calculateUnlocking(stakingLedger, eraLength, bestNumber) {\n  if ((0, _util.isUndefined)(stakingLedger)) {\n    return undefined;\n  } // select the Unlockchunks that can't be redeemed yet.\n\n\n  const unlockingChunks = stakingLedger.unlocking.filter(chunk => remainingBlocks(chunk.era, eraLength, bestNumber).gtn(0));\n\n  if (!unlockingChunks.length) {\n    return undefined;\n  } // group the Unlockchunks that have the same era and sum their values\n\n\n  const groupedResult = groupByEra(unlockingChunks);\n  const results = Object.entries(groupedResult).map(_ref2 => {\n    let _ref7 = _slicedToArray(_ref2, 2),\n        eraString = _ref7[0],\n        value = _ref7[1];\n\n    return {\n      value,\n      remainingBlocks: remainingBlocks(new _types.BlockNumber(eraString), eraLength, bestNumber)\n    };\n  });\n  return results.length ? results : undefined;\n}\n\nfunction redeemableSum(stakingLedger, eraLength, bestNumber) {\n  if ((0, _util.isUndefined)(stakingLedger)) {\n    return new _bn.default(0);\n  }\n\n  return stakingLedger.unlocking.filter(chunk => remainingBlocks(chunk.era, eraLength, bestNumber).eqn(0)).reduce((curr, prev) => {\n    return curr.add(prev.value);\n  }, new _bn.default(0));\n}\n\nfunction unwrapSessionIds(stashId, validatorIds, auraIds, nextKeys) {\n  // for 2.x we have a Vec<(ValidatorId,Keys)> of the keys\n  if (Array.isArray(nextKeys)) {\n    const validatorIdx = validatorIds.indexOf(stashId);\n    const sessionId = auraIds[validatorIdx];\n    const keys = nextKeys.find(_ref3 => {\n      let _ref8 = _slicedToArray(_ref3, 1),\n          currentId = _ref8[0];\n\n      return currentId.eq(stashId);\n    });\n    const nextSessionId = keys ? keys[1].ed25519 : sessionId;\n    return {\n      nextSessionId,\n      sessionId\n    };\n  } // substrate 1.x\n\n\n  const nextSessionId = nextKeys.isSome ? nextKeys.unwrap() : undefined;\n  return {\n    nextSessionId,\n    sessionId: nextSessionId\n  };\n}\n\nfunction withStashController(api, accountId, controllerId) {\n  const stashId = accountId;\n  return (0, _rxjs.combineLatest)([(0, _eraLength.eraLength)(api)(), (0, _bestNumber.bestNumber)(api)(), // FIXME while we have 2.x and 1.x support, don't add this to .multi -\n  // should be added when only 2.x\n  api.query.aura && api.query.aura.authorities ? api.query.aura.authorities() : (0, _rxjs.of)([]), api.queryMulti([api.query.session.queuedKeys ? [api.query.session.queuedKeys] : [api.query.session.nextKeyFor, controllerId], api.query.session.validators, [api.query.staking.ledger, controllerId], [api.query.staking.nominators, stashId], [api.query.staking.payee, stashId], [api.query.staking.stakers, stashId], [api.query.staking.validators, stashId]])]).pipe((0, _operators.map)(_ref4 => {\n    let _ref9 = _slicedToArray(_ref4, 4),\n        eraLength = _ref9[0],\n        bestNumber = _ref9[1],\n        auraIds = _ref9[2],\n        _ref9$ = _slicedToArray(_ref9[3], 7),\n        nextKeys = _ref9$[0],\n        validatorIds = _ref9$[1],\n        _stakingLedger = _ref9$[2],\n        _ref9$$ = _slicedToArray(_ref9$[3], 1),\n        nominators = _ref9$$[0],\n        rewardDestination = _ref9$[4],\n        stakers = _ref9$[5],\n        _ref9$$2 = _slicedToArray(_ref9$[6], 1),\n        validatorPrefs = _ref9$$2[0];\n\n    const stakingLedger = _stakingLedger.unwrapOr(null) || undefined;\n\n    const _unwrapSessionIds = unwrapSessionIds(stashId, validatorIds, auraIds, nextKeys),\n          sessionId = _unwrapSessionIds.sessionId,\n          nextSessionId = _unwrapSessionIds.nextSessionId;\n\n    const result = {\n      accountId,\n      controllerId,\n      nextSessionId,\n      nominators,\n      redeemable: redeemableSum(stakingLedger, eraLength, bestNumber),\n      rewardDestination,\n      sessionId,\n      stakers,\n      stakingLedger,\n      stashId,\n      unlocking: calculateUnlocking(stakingLedger, eraLength, bestNumber),\n      validatorPrefs\n    };\n    return result;\n  }), (0, _drr.drr)());\n}\n\nfunction withControllerLedger(api, accountId, stakingLedger) {\n  const controllerId = accountId;\n  const stashId = stakingLedger.stash;\n  return (0, _rxjs.combineLatest)([// FIXME while we have 2.x and 1.x support, don't add this to .multi -\n  // should be added when only 2.x\n  api.query.aura && api.query.aura.authorities ? api.query.aura.authorities() : (0, _rxjs.of)([]), api.queryMulti([api.query.session.queuedKeys ? [api.query.session.queuedKeys] : [api.query.session.nextKeyFor, controllerId], api.query.session.validators, [api.query.staking.nominators, stashId], [api.query.staking.payee, stashId], [api.query.staking.stakers, stashId], [api.query.staking.validators, stashId]])]).pipe((0, _operators.map)(_ref5 => {\n    let _ref10 = _slicedToArray(_ref5, 2),\n        auraIds = _ref10[0],\n        _ref10$ = _slicedToArray(_ref10[1], 6),\n        nextKeys = _ref10$[0],\n        validatorIds = _ref10$[1],\n        _ref10$$ = _slicedToArray(_ref10$[2], 1),\n        nominators = _ref10$$[0],\n        rewardDestination = _ref10$[3],\n        stakers = _ref10$[4],\n        _ref10$$2 = _slicedToArray(_ref10$[5], 1),\n        validatorPrefs = _ref10$$2[0];\n\n    const _unwrapSessionIds2 = unwrapSessionIds(stashId, validatorIds, auraIds, nextKeys),\n          nextSessionId = _unwrapSessionIds2.nextSessionId,\n          sessionId = _unwrapSessionIds2.sessionId;\n\n    const result = {\n      accountId,\n      controllerId,\n      nextSessionId,\n      nominators,\n      rewardDestination,\n      sessionId,\n      stakers,\n      stakingLedger,\n      stashId,\n      validatorPrefs\n    };\n    return result;\n  }), (0, _drr.drr)());\n}\n/**\n * @description From either a stash or controller id, retrieve the controllerId, stashId, nextSessionId, stakingLedger and preferences\n */\n\n\nfunction info(api) {\n  return _accountId => {\n    const accountId = new _types.AccountId(_accountId);\n    return api.queryMulti([[api.query.staking.bonded, accountId], // try to map to controller\n    [api.query.staking.ledger, accountId] // try to map to stash\n    ]).pipe((0, _operators.switchMap)(_ref6 => {\n      let _ref11 = _slicedToArray(_ref6, 2),\n          controllerId = _ref11[0],\n          stakingLedger = _ref11[1];\n\n      return controllerId.isSome // we have a controller, so input was a stash, great\n      ? withStashController(api, accountId, controllerId.unwrap()) : stakingLedger.isSome ? withControllerLedger(api, accountId, stakingLedger.unwrap()) // dangit, this is something else, ok, we are done\n      : (0, _rxjs.of)({\n        accountId\n      });\n    }), (0, _drr.drr)());\n  };\n}","map":null,"metadata":{},"sourceType":"script"}